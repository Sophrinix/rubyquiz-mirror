<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>


<!-- Start Wayback Rewrite JS Include -->
<script type="text/javascript" src="/static/js/jwplayer/jwplayer.js" ></script>
<script type="text/javascript" src="/static/js/video-embed-rewriter.js"></script>
<script type="text/javascript">
function initYTVideo(id)
{
	_wmVideos_.init("/web/", id);
}
</script>
<!-- End Wayback Rewrite JS Include -->

  <meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<title>Ruby Quiz - Bytecode Compiler (#100)</title>
	<link rel="stylesheet" type="text/css" href="/web/20120121221538cs_/http://rubyquiz.com/quiz.css" />
	<link rel="stylesheet" type="text/css" href="/web/20120121221538cs_/http://rubyquiz.com/print.css" media="print" />
</head><body>
<!-- BEGIN WAYBACK TOOLBAR INSERT -->

<script type="text/javascript" src="/static/js/disclaim-element.js" ></script>
<script type="text/javascript" src="/static/js/graph-calc.js" ></script>
<script type="text/javascript" src="/static/jflot/jquery.min.js" ></script>
<script type="text/javascript">
//<![CDATA[
var firstDate = 820454400000;
var lastDate = 1388534399999;
var wbPrefix = "/web/";
var wbCurrentUrl = "http:\/\/rubyquiz.com\/quiz100.html";

var curYear = -1;
var curMonth = -1;
var yearCount = 18;
var firstYear = 1996;
var imgWidth = 450;
var yearImgWidth = 25;
var monthImgWidth = 2;
var trackerVal = "none";
var displayDay = "21";
var displayMonth = "Jan";
var displayYear = "2012";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function showTrackers(val) {
	if(val == trackerVal) {
		return;
	}
	if(val == "inline") {
		document.getElementById("displayYearEl").style.color = "#ec008c";
		document.getElementById("displayMonthEl").style.color = "#ec008c";
		document.getElementById("displayDayEl").style.color = "#ec008c";		
	} else {
		document.getElementById("displayYearEl").innerHTML = displayYear;
		document.getElementById("displayYearEl").style.color = "#ff0";
		document.getElementById("displayMonthEl").innerHTML = displayMonth;
		document.getElementById("displayMonthEl").style.color = "#ff0";
		document.getElementById("displayDayEl").innerHTML = displayDay;
		document.getElementById("displayDayEl").style.color = "#ff0";
	}
   document.getElementById("wbMouseTrackYearImg").style.display = val;
   document.getElementById("wbMouseTrackMonthImg").style.display = val;
   trackerVal = val;
}
function getElementX2(obj) {
	var thing = jQuery(obj);
	if((thing == undefined) 
			|| (typeof thing == "undefined") 
			|| (typeof thing.offset == "undefined")) {
		return getElementX(obj);
	}
	return Math.round(thing.offset().left);
}
function trackMouseMove(event,element) {

   var eventX = getEventX(event);
   var elementX = getElementX2(element);
   var xOff = eventX - elementX;
	if(xOff < 0) {
		xOff = 0;
	} else if(xOff > imgWidth) {
		xOff = imgWidth;
	}
   var monthOff = xOff % yearImgWidth;

   var year = Math.floor(xOff / yearImgWidth);
	var yearStart = year * yearImgWidth;
   var monthOfYear = Math.floor(monthOff / monthImgWidth);
   if(monthOfYear > 11) {
       monthOfYear = 11;
   }
   // 1 extra border pixel at the left edge of the year:
   var month = (year * 12) + monthOfYear;
   var day = 1;
	if(monthOff % 2 == 1) {
		day = 15;
	}
	var dateString = 
		zeroPad(year + firstYear) + 
		zeroPad(monthOfYear+1,2) +
		zeroPad(day,2) + "000000";

	var monthString = prettyMonths[monthOfYear];
	document.getElementById("displayYearEl").innerHTML = year + 1996;
	document.getElementById("displayMonthEl").innerHTML = monthString;
	// looks too jarring when it changes..
	//document.getElementById("displayDayEl").innerHTML = zeroPad(day,2);

	var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
	document.getElementById('wm-graph-anchor').href = url;

   //document.getElementById("wmtbURL").value="evX("+eventX+") elX("+elementX+") xO("+xOff+") y("+year+") m("+month+") monthOff("+monthOff+") DS("+dateString+") Moy("+monthOfYear+") ms("+monthString+")";
   if(curYear != year) {
       var yrOff = year * yearImgWidth;
       document.getElementById("wbMouseTrackYearImg").style.left = yrOff + "px";
       curYear = year;
   }
   if(curMonth != month) {
       var mtOff = year + (month * monthImgWidth) + 1;
       document.getElementById("wbMouseTrackMonthImg").style.left = mtOff + "px";
       curMonth = month;
   }
}
//]]>
</script>

<style type="text/css">body{margin-top:0!important;padding-top:0!important;min-width:800px!important;}#wm-ipp a:hover{text-decoration:underline!important;}</style>
<div id="wm-ipp" style="display:none; position:relative;padding:0 5px;min-height:70px;min-width:800px; z-index:9000;">
<div id="wm-ipp-inside" style="position:fixed;padding:0!important;margin:0!important;width:97%;min-width:780px;border:5px solid #000;border-top:none;background-image:url(/static/images/toolbar/wm_tb_bk_trns.png);text-align:center;-moz-box-shadow:1px 1px 3px #333;-webkit-box-shadow:1px 1px 3px #333;box-shadow:1px 1px 3px #333;font-size:11px!important;font-family:'Lucida Grande','Arial',sans-serif!important;">
   <table style="border-collapse:collapse;margin:0;padding:0;width:100%;"><tbody><tr>
   <td style="padding:10px;vertical-align:top;min-width:110px;">
   <a href="/web/" title="Wayback Machine home page" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"/></a>
   </td>
   <td style="padding:0!important;text-align:center;vertical-align:top;width:100%;">

       <table style="border-collapse:collapse;margin:0 auto;padding:0;width:570px;"><tbody><tr>
       <td style="padding:3px 0;" colspan="2">
       <form target="_top" method="get" action="/web/form-submit.jsp" name="wmtb" id="wmtb" style="margin:0!important;padding:0!important;"><input type="text" name="url" id="wmtbURL" value="http://rubyquiz.com/quiz100.html" style="width:400px;font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;" onfocus="javascript:this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20120121221538" /><input type="submit" value="Go" style="font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;margin-left:5px;" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td style="vertical-align:bottom;padding:5px 0 0 0!important;" rowspan="2">
           <table style="border-collapse:collapse;width:110px;color:#99a;font-family:'Helvetica','Lucida Grande','Arial',sans-serif;"><tbody>
			
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr style="width:110px;height:16px;font-size:10px!important;">
           	<td style="padding-right:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20101127173051/http://rubyquiz.com/quiz100.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="27 Nov 2010"><strong>NOV</strong></a>
		                
               </td>
               <td id="displayMonthEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight:bold;text-transform:uppercase;width:34px;height:15px;padding-top:1px;text-align:center;" title="You are here: 22:15:38 Jan 21, 2012">JAN</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20120418123917/http://www.rubyquiz.com/quiz100.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="18 Apr 2012"><strong>APR</strong></a>
		                
               </td>
           </tr>

           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr>
               <td style="padding-right:9px;white-space:nowrap;overflow:visible;text-align:right!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="/web/20101127173051/http://rubyquiz.com/quiz100.html" title="17:30:51 Nov 27, 2010" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
		                
               </td>
               <td id="displayDayEl" style="background:#000;color:#ff0;width:34px;height:24px;padding:2px 0 0 0;text-align:center;font-size:24px;font-weight: bold;" title="You are here: 22:15:38 Jan 21, 2012">21</td>
				<td style="padding-left:9px;white-space:nowrap;overflow:visible;text-align:left!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="/web/20120122033507/http://rubyquiz.com/quiz100.html" title="3:35:07 Jan 22, 2012" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"/></a>
		                
			    </td>
           </tr>

           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr style="width:110px;height:13px;font-size:9px!important;">
				<td style="padding-right:9px;font-size:11px!important;font-weight: bold;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20101127173051/http://rubyquiz.com/quiz100.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="27 Nov 2010"><strong>2010</strong></a>
		                
               </td>
               <td id="displayYearEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight: bold;padding-top:1px;width:34px;height:13px;text-align:center;" title="You are here: 22:15:38 Jan 21, 2012">2012</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight: bold;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20130215052618/http://rubyquiz.com/quiz100.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="15 Feb 2013"><strong>2013</strong></a>
		                
				</td>
           </tr>
           </tbody></table>
       </td>

       </tr>
       <tr>
       <td style="vertical-align:middle;padding:0!important;">
           <a href="/web/20120121221538*/http://rubyquiz.com/quiz100.html" style="color:#33f;font-size:11px;font-weight:bold;background-color:transparent;border:none;" title="See a list of every capture for this URL"><strong>26 captures</strong></a>
           <div style="margin:0!important;padding:0!important;color:#666;font-size:9px;padding-top:2px!important;white-space:nowrap;" title="Timespan for captures of this URL">21 Apr 07 - 15 Feb 13</div>
       </td>
       <td style="padding:0!important;">
       <a style="position:relative; white-space:nowrap; width:450px;height:27px;" href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" style="position:relative; white-space:nowrap; width:450px;height:27px;background-color:#fff;cursor:pointer;border-right:1px solid #ccc;" title="Explore captures for this URL">
			<img id="sparklineImgId" style="position:absolute; z-index:9012; top:0px; left:0px;"
				onmouseover="showTrackers('inline');" 
				onmouseout="showTrackers('none');"
				onmousemove="trackMouseMove(event,this)"
				alt="sparklines"
				width="450"
				height="27"
				border="0"
				src="/web/jsp/graph.jsp?graphdata=450_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000000_2007:-1:000100000000_2008:-1:000000000000_2009:-1:000000000000_2010:-1:000000000010_2011:-1:000000000000_2012:0:30018000a100_2013:-1:010000000000"></img>
			<img id="wbMouseTrackYearImg" 
				style="display:none; position:absolute; z-index:9010;"
				width="25" 
				height="27"
				border="0"
				src="/static/images/toolbar/transp-yellow-pixel.png"></img>
			<img id="wbMouseTrackMonthImg"
				style="display:none; position:absolute; z-index:9011; " 
				width="2"
				height="27" 
				border="0"
				src="/static/images/toolbar/transp-red-pixel.png"></img>
       </div>
		</a>

       </td>
       </tr></tbody></table>
   </td>
   <td style="text-align:right;padding:5px;width:65px;font-size:11px!important;">
       <a href="javascript:;" onclick="document.getElementById('wm-ipp').style.display='none';" style="display:block;padding-right:18px;background:url(/static/images/toolbar/wm_tb_close.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;margin-bottom:23px;background-color:transparent;border:none;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="display:block;padding-right:18px;background:url(/static/images/toolbar/wm_tb_help.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;background-color:transparent;border:none;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>

</div>
</div>
<script type="text/javascript">
 var wmDisclaimBanner = document.getElementById("wm-ipp");
 if(wmDisclaimBanner != null) {
   disclaimElement(wmDisclaimBanner);
 }
</script>
<!-- END WAYBACK TOOLBAR INSERT -->

	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Bytecode Compiler (#100)</span>
			<p>by Ross Bamford</p>
			<p>Note: This quiz isn't really as much work as it might seem!</p>
			<p>This quiz involves writing (in Ruby, of course) a compiler for basic arithmetic expressions. The output from this compiler should be an array of unsigned byte-sized ints, which can be fed into the included interpreter (http://www.rubyquiz.com/interp.rb) in order to execute the compiled expression.</p>
			<p>The bytecode format is very simple, while the interpreter is also very simple, implemented as a stack machine. They have the following general characteristics:</p>
			<p class="example">* Bytecode is stored as an array of unsigned byte-sized Fixnums.<br />* All stack-bound numbers are signed integers<br />* The following operations are supported:<br />  * Addition<br />  * Subtraction<br />  * Multiplication<br />  * Division<br />  * Raise to power<br />  * Integer modulo<br />* Where an operator would return a floating point value,<br />  the value is truncated to an integer.<br />* Short CONST and long LCONST instructions allow constants<br />  to be pushed to the stack. These instructions expect their<br />  operands to hold a signed short or long, respectively,<br />  in network byte order.</p>
			<p>Your compiler interface should be via a singleton method on a module 'Compiler', taking a string, such that:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    Compiler.compile(<span class="string">'3+2'</span>)<br /><br /></div></div>
			<p>Returns an array of instructions (and operands) that, when fed to the interpreter, will execute the expression 3+2 and return the result (hopefully 5). For example, a correct (but non-optimal) result from the above call would be:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    [2,0,0,0,3,   <span class="comment"># LCONST 3</span><br />     2,0,0,0,2,   <span class="comment"># LCONST 2</span><br />     10]          <span class="comment"># ADD</span><br /><br /></div></div>
			<p>Your compiler should support all basic arithmetic operations and explicit precedence (parenthesis). As standard, syntax/precedence/ associativity/etc. should follow Ruby itself. Obviously, specific implementation is entirely up to you, though bear in mind that your compiler must be capable of running inline in the same Ruby process as the interpreter, without affecting any code outside itself.</p>
			<p>The quiz also includes a number of tests (http://www.rubyquiz.com/test_bytecode.rb) that will test your compiler's functionality, with expressions becoming more complex as the tests go on. To pass all the tests, a compiler will have to not only generate correct bytecode, but it will also need to generate the shortest code it can for a given expression.</p>
			<p>Here is the bytecode spec:</p>
			<p class="example"># 0x01: CONST (cbyte1, cbyte2) ... =&gt; ..., const<br />  Push a 15-bit signed integer to the stack.<br />  The two bytes immediately following the instruction represent the<br />  constant.<br /><br /># 0x02: LCONST (cbyte1, cbyte2, cbyte3, cbyte4) ... =&gt; ..., const<br />  Push a 31-bit signed integer to the stack.<br />  The four bytes immediately following the instruction represent the<br />  constant.<br /><br /># 0x0a: ADD () ..., value1, value2 =&gt; ..., result<br />  Pop the top two values from the stack, add them, and push the result<br />  back onto the stack.<br /><br /># 0x0b: SUB () ..., value1, value2 =&gt; ..., result<br />  Pop the top two values from the stack, subtract value2 from value1,<br />  and push the result back onto the stack.<br /><br /># 0x0c: MUL () ..., value1, value2 =&gt; ..., result<br />  Pop the top two values from the stack, multiply value1 by value2,<br />  and push the result back onto the stack.<br /><br /># 0x0d: POW () ..., value1, value2 =&gt; ..., result<br />  Pop the top two values from the stack, raise value1 to the power of<br />  value2, and push the result back onto the stack.<br /><br /># 0x0e: DIV () ..., value1, value2 =&gt; ..., result<br />  Pop the top two values from the stack, divide value1 by value2,<br />  and push the result back onto the stack.<br /><br /># 0x0f: MOD () ..., value1, value2 =&gt; ..., result<br />  Pop the top two values from the stack, modulo value1 by value2,<br />  and push the result back onto the stack.<br /><br /># 0xa0: SWAP () ..., value1, value2 =&gt; ..., value2, value1<br />  Swap the top two stack values.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>I'm very glad this quiz came along, because I honestly had no idea what "bytecode" meant before I read this quiz.  I think it was good for dumbing the idea down for the masses (or just me, if everyone else already knew this stuff).  Not all of us port entire virtual machines, as the quiz creator does.</p>
			<p>There were a couple of approaches to this week's quiz.  One strategy was to convert the expression into valid Ruby that would emit the bytecode and let Ruby do the parsing.  This works for this parsing problem because Ruby's expression rules are comparable to those specified by the quiz.  I think we can break down one of those solutions to better understand what was involved with this problem.</p>
			<p>Here's a chunk of code from Cameron Pope's solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">module</span> CreateExpressions<br />      <span class="keyword">def</span> +(other) Expr.new(:add, <span class="keyword">self</span>, other) <span class="keyword">end</span><br />      <span class="keyword">def</span> -(other) Expr.new(:sub, <span class="keyword">self</span>, other) <span class="keyword">end</span><br />      <span class="keyword">def</span> *(other) Expr.new(:mul, <span class="keyword">self</span>, other) <span class="keyword">end</span><br />      <span class="keyword">def</span> /(other) Expr.new(:div, <span class="keyword">self</span>, other) <span class="keyword">end</span><br />      <span class="keyword">def</span> %(other) Expr.new(:mod, <span class="keyword">self</span>, other) <span class="keyword">end</span><br />      <span class="keyword">def</span> **(other) Expr.new(:pow, <span class="keyword">self</span>, other) <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>You can see a set of operator definitions here, matching those needed by the quiz.  Instead of these methods doing what they normally do (math), the versions we see here just create and return an Expr object.  Let's have a look at that definition now:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Expr<br />      include CreateExpressions<br />      OPCODES = {:add =&gt; 0x0a, :sub =&gt; 0x0b, :mul =&gt; 0x0c, :pow =&gt; 0x0d,<br />        :div =&gt; 0x0e, :mod =&gt; 0x0f}<br /><br />      <span class="keyword">def</span> initialize(op, a, b)<br />        <span class="variable">@op</span> = op<br />        <span class="variable">@first</span> = a<br />        <span class="variable">@second</span> = b<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> to_s<br />        <span class="string">"(#{@op.to_s} #{@first.to_s} #{@second.to_s})"</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> emit<br />        <span class="variable">@first</span>.emit &lt;&lt; <span class="variable">@second</span>.emit &lt;&lt; OPCODES[<span class="variable">@op</span>]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Ignoring the to_s() method, which is just for debugging, this object is trivial.  It stores an operator and operands, and can emit() bytecode.  To do that, it forwards the emit() call to both operands, which may be nested Expr objects (say from parenthetical expressions) or something else we will discuss in just a moment.  emit() also looks up the operator's bytecode and appends that to the results of the operand emit()s.</p>
			<p>Note that this class include()s all of the operator definitions we saw earlier.  This means you can add, multiply, etc. Expr objects, which yields a new Expr with the original Epxrs nested in the operands.</p>
			<p>That covers expressions, but what about plain old numbers?  For that, there is another class:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Const<br />      include CreateExpressions<br />      OPCODES = {2 =&gt; 0x01, 4 =&gt; 0x02}<br /><br />      <span class="keyword">def</span> initialize(i)<br />        <span class="variable">@value</span> = i<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> to_s<br />        <span class="variable">@value</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> emit<br />        <span class="keyword">case</span> <span class="variable">@value</span><br />          <span class="keyword">when</span> (-32768..32767): bytes = [<span class="variable">@value</span>].pack(<span class="string">"n"</span>).unpack(<span class="string">"C*"</span>)<br />          <span class="keyword">else</span> bytes = [<span class="variable">@value</span>].pack(<span class="string">"N"</span>).unpack(<span class="string">"C*"</span>)<br />        <span class="keyword">end</span><br />        bytes.insert 0, OPCODES[bytes.size]<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>We have pretty much the same pattern here, save that emit() converts the number to the bytecode for the properly sized constant plus the packed bytes.  Again we see the arithmetic operators include()ed, so these too can be combined with other Const and Expr objects.</p>
			<p>Now we need a means to turn the normal numbers of the expression into Const objects:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Fixnum<br />      <span class="keyword">def</span> to_const<br />        Const.new(<span class="keyword">self</span>)<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Yep, that will do just that.</p>
			<p>All that's left is to put it to use:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Compiler<br />      <span class="keyword">def</span> <span class="keyword">self</span>.compile(expr)<br />        <span class="keyword">self</span>.mangle(expr).emit.flatten<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> <span class="keyword">self</span>.explain(expr)<br />        <span class="keyword">self</span>.mangle(expr).to_s<br />      <span class="keyword">end</span><br /><br />    private<br />      <span class="keyword">def</span> <span class="keyword">self</span>.mangle(expr)<br />        eval(expr.gsub(<span class="string">/\d+/</span>) {|s| <span class="string">"#{s}.to_const()"</span>})<br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The mangle() method is the heart of this solution.  A simple Regexp is used to tack a to_const() call on to each number of the expression and a hand-off is made to eval() to build up the indicated combination of Const and Expr objects.  Once mangle()d, the result is emit()ted and flatten()ed into the final bytecode Array in compile().</p>
			<p>That's easy enough to understand and it works just fine in this instance.  However, what if the rules differed from Ruby's and you couldn't lean on Ruby's parser?  In that case, you would have to roll your own parser, which some decided to do.</p>
			<p>Luckily there is already a popular algorithm for unrolling infix arithmetic expressions into the RPN order required by bytecode spec:</p>
			<p><a href="/web/20120121221538/http://en.wikipedia.org/wiki/Shunting_yard_algorithm">Shunting Yard Algorithm</a></p>
			<p>Several people employed this strategy, including Daniel Martin:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># This is a solution to Ruby Quiz #100</span><br />    <span class="comment">#</span><br />    <span class="comment"># It's basically just a shunting algorithm, but with a twist</span><br />    <span class="comment"># since it needs to distinguish between a "-" that's part of</span><br />    <span class="comment"># a number and a "-" that's an operator.  To do that, I use</span><br />    <span class="comment"># a state machine while parsing to remember if I need next</span><br />    <span class="comment"># an operator or an integer.</span><br /><br />    require <span class="string">'strscan'</span><br />    <span class="keyword">class</span> Compiler<br />      <span class="comment"># A small class made so that I can use case ... when</span><br />      <span class="comment"># with a StringScanner</span><br />      <span class="keyword">class</span> Token &lt; Regexp<br />        <span class="keyword">def</span> initialize(re)<br />          <span class="keyword">super</span>(re)<br />        <span class="keyword">end</span><br />        <span class="comment"># Using is_a? instead of respond_to? isn't very duck-typey,</span><br />        <span class="comment"># but unfortunately String#scan and StringScanner#scan mean</span><br />        <span class="comment"># completely different things.</span><br />        <span class="keyword">def</span> ===(s)<br />          <span class="keyword">if</span> (s.is_a?(StringScanner))<br />            s.scan(<span class="keyword">self</span>)<br />          <span class="keyword">else</span><br />            <span class="keyword">super</span>(s)<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>This first class of Daniel's solution is really just a Regexp with a custom case equals method.  This sets up an elegant syntax for the solution proper we will encounter in a bit.</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># The tokens I need</span><br />      WSPACE = Token.new(<span class="string">/\s+/</span>)<br />      LPAREN = Token.new(<span class="string">/\(/</span>)<br />      RPAREN = Token.new(<span class="string">/\)/</span>)<br />      OP  = Token.new(<span class="string">/\*\*|[+*%\/-]/</span>)<br />      NEG = Token.new(<span class="string">/-/</span>)<br />      INT = Token.new(<span class="string">/\d+/</span>)<br /><br />      OpValMap = {<span class="string">'+'</span> =&gt; 0x0a, <span class="string">'-'</span> =&gt; 0x0b, <span class="string">'*'</span> =&gt; 0x0c,<br />                  <span class="string">'**'</span> =&gt; 0x0d, <span class="string">'/'</span> =&gt; 0x0e, <span class="string">'%'</span> =&gt; 0x0f}<br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here you see the class used to build the Tokens for lexxing the expression content.  These are very basic regular expressions.</p>
			<p>Here are the interface methods required by the quiz solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="keyword">def</span> initialize(instring)<br />        <span class="variable">@scanner</span> = StringScanner.new(instring)<br />        <span class="variable">@opstack</span> = Array.new<br />        <span class="variable">@outarr</span> = Array.new<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> compile()<br />        state = :state_int<br />        <span class="keyword">while</span> state != :state_end<br />          <span class="keyword">case</span> <span class="variable">@scanner</span><br />          <span class="keyword">when</span> WSPACE<br />            <span class="keyword">next</span><br />          <span class="keyword">else</span><br />            state = send(state)<br />            raise <span class="string">"Syntax error at index #{@scanner.pos}"</span> <span class="keyword">if</span> ! state<br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />        <span class="keyword">while</span> ! <span class="variable">@opstack</span>.empty?<br />          op = <span class="variable">@opstack</span>.pop<br />          raise <span class="string">"Mismatched parens"</span> <span class="keyword">if</span> LPAREN === op<br />          <span class="variable">@outarr</span> &lt;&lt; OpValMap[op]<br />        <span class="keyword">end</span><br />        <span class="variable">@outarr</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Class method as required by the test harness</span><br />      <span class="keyword">def</span> <span class="keyword">self</span>.compile(instring)<br />        new(instring).compile<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Notice that initialize() sets up the stack and output Arrays needed by the Shunting Yard algorithm.  The compile() method wraps a state machine we will examine the workings of shortly.  You can see that is discards whitespace as needed, forwards to state methods, pop()s the final operators as the algorithm requires, and returns the resulting output Array.  The class compile() is just a wrapper over the other two methods.</p>
			<p>The heart of what is going on here is hidden in the state methods.  From compile() we saw that the initial state for the machine is :state_int, so let's begin with that method:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      private<br /><br />      <span class="comment"># ...</span><br /><br />      <span class="comment"># state where we're expecting an integer or left paren</span><br />      <span class="keyword">def</span> state_int<br />        <span class="keyword">case</span> <span class="variable">@scanner</span><br />        <span class="keyword">when</span> LPAREN<br />          <span class="variable">@opstack</span> &lt;&lt; <span class="variable">@scanner</span>.matched<br />          :state_int<br />        <span class="keyword">when</span> INT<br />          integer(<span class="variable">@scanner</span>.matched.to_i)<br />          :state_op<br />        <span class="keyword">when</span> NEG<br />          :state_neg<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Here we begin to see the magic of the Token class.  Matching a Token advances the StringScanner index and matched() can then be used to grab the element.</p>
			<p>The LPAREN when clause is right out of the algorithm description, and the INT clause is pretty obviously if you know that integer() handles the constant conversion.  The NEG clause is needed to distinguish an unary minus from the binary operator.  Note that each case returns the next expected state for the machine.</p>
			<p>Here's the integer() helper we have seen before:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># Handle an integer</span><br />      <span class="keyword">def</span> integer(i)<br />        <span class="keyword">if</span> (i &lt;= 32767 <span class="keyword">and</span> i &gt;= -32768)<br />          <span class="variable">@outarr</span> &lt;&lt; 0x01<br />          <span class="variable">@outarr</span>.push(*([i].pack(<span class="string">"n"</span>).unpack(<span class="string">"C*"</span>)))<br />        <span class="keyword">else</span><br />          <span class="variable">@outarr</span> &lt;&lt; 0x02<br />          <span class="variable">@outarr</span>.push(*([i].pack(<span class="string">"N"</span>).unpack(<span class="string">"C*"</span>)))<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The only difference here is that constants are pushed onto the output Array as required by the algorithm.</p>
			<p>Let's return to the state methods:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># Expecting an operator or right paren</span><br />      <span class="keyword">def</span> state_op<br />        <span class="keyword">case</span> <span class="variable">@scanner</span><br />        <span class="keyword">when</span> RPAREN<br />          <span class="keyword">while</span> <span class="keyword">not</span> LPAREN === <span class="variable">@opstack</span>[-1]<br />            raise <span class="string">"Mismatched parens"</span> <span class="keyword">if</span> <span class="variable">@opstack</span>.empty?<br />            <span class="variable">@outarr</span> &lt;&lt; OpValMap[<span class="variable">@opstack</span>.pop]<br />          <span class="keyword">end</span><br />          <span class="variable">@opstack</span>.pop<br />          :state_op<br />        <span class="keyword">when</span> OP<br />          op = <span class="variable">@scanner</span>.matched<br />          <span class="keyword">while</span> is_lower(<span class="variable">@opstack</span>[-1], op)<br />            <span class="variable">@outarr</span> &lt;&lt; OpValMap[<span class="variable">@opstack</span>.pop]<br />          <span class="keyword">end</span><br />          <span class="variable">@opstack</span> &lt;&lt; op<br />          :state_int<br />        <span class="keyword">else</span><br />          <span class="comment"># I would handle this with an EOS token, but unfortunately</span><br />          <span class="comment"># StringScanner is broken w.r.t. @scanner.scan(/$/)</span><br />          :state_end <span class="keyword">if</span> <span class="variable">@scanner</span>.eos?<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>Again, the RPAREN clause is right out of the algorithm description.  The OP clause is as well and you can see that it handles the precedence check via the is_lower() helper method.  The else clause gives us our exit state when the expression has been exhausted.</p>
			<p>Here's the is_lower() helper:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># Define the precedence order</span><br />      <span class="comment"># One thing to note is that for an operator a,</span><br />      <span class="comment"># is_lower(a,a) being true will make that operator</span><br />      <span class="comment"># left-associative, while is_lower(a,a) being false</span><br />      <span class="comment"># makes that operator right-associative.  Note that</span><br />      <span class="comment"># we want ** to be right associative, but all other</span><br />      <span class="comment"># operators to be left associative.</span><br />      <span class="keyword">def</span> is_lower(op_on_stack, op_in_hand)<br />        <span class="keyword">case</span> op_on_stack<br />          <span class="keyword">when</span> <span class="keyword">nil</span>, LPAREN; <span class="keyword">false</span><br />          <span class="keyword">when</span> <span class="string">/\*\*|[*\/%]/</span>; op_in_hand =~ <span class="string">/^.$/</span><br />          <span class="keyword">when</span> <span class="string">/[+-]/</span>;        op_in_hand =~ <span class="string">/[+-]/</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br /><br /></div></div>
			<p>The comment surely explains this better than I can, but the point of this method is to resolve whether or not the operator we just matched is lower in precedence than the operator on the stack.  For example, in the last line, when we have a plus or minus on the stack only another plus or minus would trigger the true result.</p>
			<p>Here's the final state:</p>
			<div class="code"><span class="type">ruby</span><div class="body">      <span class="comment"># ...</span><br /><br />      <span class="comment"># The state where we've seen a minus and are expecting</span><br />      <span class="comment"># the rest of the integer</span><br />      <span class="keyword">def</span> state_neg<br />        <span class="keyword">case</span> <span class="variable">@scanner</span><br />        <span class="keyword">when</span> INT<br />          integer(-(<span class="variable">@scanner</span>.matched.to_i))<br />          :state_op<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># ...</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This just reads the constant following a negation operator and ensures that it is negated.</p>
			<p>Those are two different approaches that pass the quiz tests.  It's probably slightly easier to lean on Ruby in cases like this where you know you can get away with it.  If you can't though, the custom parser isn't too much more work as Daniel shows.</p>
			<p>My thanks to all who taught me many things I didn't know about bytecode compilation through their solutions and to Ross Bamford for the educational quiz.</p>
			<p>Tomorrow we will play with VCRs and I'm told that dates me...</p>
		</div>
		<div id="logo"><img src="/web/20120121221538im_/http://rubyquiz.com/images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223589">Wilson Bilkovich</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223590">Bill Dolinar</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223595">Cameron Pope</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223598">J. Eric Ivancich</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223601">Dennis Ranke</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223649">Ed Brannin</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223663">Daniel Martin</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223667">Daniel Martin (2)</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223668">Wilson Bilkovich (2)</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223670">Mike Harris</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223680">Marcel Ward</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223743">Ken Allen</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223777">Adam Shelly</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223803">Bill Dolinar (2)</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/223899">Robert Conn</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/224037">Mike Harris (2)</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/224055">Ross Bamford</a></li>
				<li><a href="/web/20120121221538/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/224105">Louis J Scoras</a></li>
			</ol>
			<p><a href="/web/20120121221538/http://rubyquiz.com/quiz100_sols.zip">Download Solutions</a></p>
			<p><a href="/web/20120121221538/http://rubyquiz.com/index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>





<!--
     FILE ARCHIVED ON 22:15:38 Jan 21, 2012 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 13:10:27 Jun 5, 2013.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
