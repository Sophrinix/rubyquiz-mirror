<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>


<!-- Start Wayback Rewrite JS Include -->
<script type="text/javascript" src="/static/js/jwplayer/jwplayer.js" ></script>
<script type="text/javascript" src="/static/js/video-embed-rewriter.js"></script>
<script type="text/javascript">
function initYTVideo(id)
{
	_wmVideos_.init("/web/", id);
}
</script>
<!-- End Wayback Rewrite JS Include -->

	<title>Ruby Quiz - Amazing Mazes (#31)</title>
	<link rel="stylesheet" type="text/css" href="/web/20120121210115cs_/http://rubyquiz.com/quiz.css" />
	<link rel="stylesheet" type="text/css" href="/web/20120121210115cs_/http://rubyquiz.com/print.css" media="print" />
</head><body>
<!-- BEGIN WAYBACK TOOLBAR INSERT -->

<script type="text/javascript" src="/static/js/disclaim-element.js" ></script>
<script type="text/javascript" src="/static/js/graph-calc.js" ></script>
<script type="text/javascript" src="/static/jflot/jquery.min.js" ></script>
<script type="text/javascript">
//<![CDATA[
var firstDate = 820454400000;
var lastDate = 1388534399999;
var wbPrefix = "/web/";
var wbCurrentUrl = "http:\/\/rubyquiz.com\/quiz31.html";

var curYear = -1;
var curMonth = -1;
var yearCount = 18;
var firstYear = 1996;
var imgWidth = 450;
var yearImgWidth = 25;
var monthImgWidth = 2;
var trackerVal = "none";
var displayDay = "21";
var displayMonth = "Jan";
var displayYear = "2012";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function showTrackers(val) {
	if(val == trackerVal) {
		return;
	}
	if(val == "inline") {
		document.getElementById("displayYearEl").style.color = "#ec008c";
		document.getElementById("displayMonthEl").style.color = "#ec008c";
		document.getElementById("displayDayEl").style.color = "#ec008c";		
	} else {
		document.getElementById("displayYearEl").innerHTML = displayYear;
		document.getElementById("displayYearEl").style.color = "#ff0";
		document.getElementById("displayMonthEl").innerHTML = displayMonth;
		document.getElementById("displayMonthEl").style.color = "#ff0";
		document.getElementById("displayDayEl").innerHTML = displayDay;
		document.getElementById("displayDayEl").style.color = "#ff0";
	}
   document.getElementById("wbMouseTrackYearImg").style.display = val;
   document.getElementById("wbMouseTrackMonthImg").style.display = val;
   trackerVal = val;
}
function getElementX2(obj) {
	var thing = jQuery(obj);
	if((thing == undefined) 
			|| (typeof thing == "undefined") 
			|| (typeof thing.offset == "undefined")) {
		return getElementX(obj);
	}
	return Math.round(thing.offset().left);
}
function trackMouseMove(event,element) {

   var eventX = getEventX(event);
   var elementX = getElementX2(element);
   var xOff = eventX - elementX;
	if(xOff < 0) {
		xOff = 0;
	} else if(xOff > imgWidth) {
		xOff = imgWidth;
	}
   var monthOff = xOff % yearImgWidth;

   var year = Math.floor(xOff / yearImgWidth);
	var yearStart = year * yearImgWidth;
   var monthOfYear = Math.floor(monthOff / monthImgWidth);
   if(monthOfYear > 11) {
       monthOfYear = 11;
   }
   // 1 extra border pixel at the left edge of the year:
   var month = (year * 12) + monthOfYear;
   var day = 1;
	if(monthOff % 2 == 1) {
		day = 15;
	}
	var dateString = 
		zeroPad(year + firstYear) + 
		zeroPad(monthOfYear+1,2) +
		zeroPad(day,2) + "000000";

	var monthString = prettyMonths[monthOfYear];
	document.getElementById("displayYearEl").innerHTML = year + 1996;
	document.getElementById("displayMonthEl").innerHTML = monthString;
	// looks too jarring when it changes..
	//document.getElementById("displayDayEl").innerHTML = zeroPad(day,2);

	var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
	document.getElementById('wm-graph-anchor').href = url;

   //document.getElementById("wmtbURL").value="evX("+eventX+") elX("+elementX+") xO("+xOff+") y("+year+") m("+month+") monthOff("+monthOff+") DS("+dateString+") Moy("+monthOfYear+") ms("+monthString+")";
   if(curYear != year) {
       var yrOff = year * yearImgWidth;
       document.getElementById("wbMouseTrackYearImg").style.left = yrOff + "px";
       curYear = year;
   }
   if(curMonth != month) {
       var mtOff = year + (month * monthImgWidth) + 1;
       document.getElementById("wbMouseTrackMonthImg").style.left = mtOff + "px";
       curMonth = month;
   }
}
//]]>
</script>

<style type="text/css">body{margin-top:0!important;padding-top:0!important;min-width:800px!important;}#wm-ipp a:hover{text-decoration:underline!important;}</style>
<div id="wm-ipp" style="display:none; position:relative;padding:0 5px;min-height:70px;min-width:800px; z-index:9000;">
<div id="wm-ipp-inside" style="position:fixed;padding:0!important;margin:0!important;width:97%;min-width:780px;border:5px solid #000;border-top:none;background-image:url(/static/images/toolbar/wm_tb_bk_trns.png);text-align:center;-moz-box-shadow:1px 1px 3px #333;-webkit-box-shadow:1px 1px 3px #333;box-shadow:1px 1px 3px #333;font-size:11px!important;font-family:'Lucida Grande','Arial',sans-serif!important;">
   <table style="border-collapse:collapse;margin:0;padding:0;width:100%;"><tbody><tr>
   <td style="padding:10px;vertical-align:top;min-width:110px;">
   <a href="/web/" title="Wayback Machine home page" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"/></a>
   </td>
   <td style="padding:0!important;text-align:center;vertical-align:top;width:100%;">

       <table style="border-collapse:collapse;margin:0 auto;padding:0;width:570px;"><tbody><tr>
       <td style="padding:3px 0;" colspan="2">
       <form target="_top" method="get" action="/web/form-submit.jsp" name="wmtb" id="wmtb" style="margin:0!important;padding:0!important;"><input type="text" name="url" id="wmtbURL" value="http://rubyquiz.com/quiz31.html" style="width:400px;font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;" onfocus="javascript:this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20120121210115" /><input type="submit" value="Go" style="font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;margin-left:5px;" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td style="vertical-align:bottom;padding:5px 0 0 0!important;" rowspan="2">
           <table style="border-collapse:collapse;width:110px;color:#99a;font-family:'Helvetica','Lucida Grande','Arial',sans-serif;"><tbody>
			
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr style="width:110px;height:16px;font-size:10px!important;">
           	<td style="padding-right:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20110824083212/http://www.rubyquiz.com/quiz31.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="24 Aug 2011"><strong>AUG</strong></a>
		                
               </td>
               <td id="displayMonthEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight:bold;text-transform:uppercase;width:34px;height:15px;padding-top:1px;text-align:center;" title="You are here: 21:01:15 Jan 21, 2012">JAN</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20120502040555/http://rubyquiz.com/quiz31.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="2 May 2012"><strong>MAY</strong></a>
		                
               </td>
           </tr>

           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr>
               <td style="padding-right:9px;white-space:nowrap;overflow:visible;text-align:right!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="/web/20120113131405/http://www.rubyquiz.com/quiz31.html" title="13:14:05 Jan 13, 2012" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
		                
               </td>
               <td id="displayDayEl" style="background:#000;color:#ff0;width:34px;height:24px;padding:2px 0 0 0;text-align:center;font-size:24px;font-weight: bold;" title="You are here: 21:01:15 Jan 21, 2012">21</td>
				<td style="padding-left:9px;white-space:nowrap;overflow:visible;text-align:left!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="/web/20120502040555/http://rubyquiz.com/quiz31.html" title="4:05:55 May 2, 2012" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"/></a>
		                
			    </td>
           </tr>

           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr style="width:110px;height:13px;font-size:9px!important;">
				<td style="padding-right:9px;font-size:11px!important;font-weight: bold;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20101127180758/http://rubyquiz.com/quiz31.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="27 Nov 2010"><strong>2010</strong></a>
		                
               </td>
               <td id="displayYearEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight: bold;padding-top:1px;width:34px;height:13px;text-align:center;" title="You are here: 21:01:15 Jan 21, 2012">2012</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight: bold;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20130215053005/http://rubyquiz.com/quiz31.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="15 Feb 2013"><strong>2013</strong></a>
		                
				</td>
           </tr>
           </tbody></table>
       </td>

       </tr>
       <tr>
       <td style="vertical-align:middle;padding:0!important;">
           <a href="/web/20120121210115*/http://rubyquiz.com/quiz31.html" style="color:#33f;font-size:11px;font-weight:bold;background-color:transparent;border:none;" title="See a list of every capture for this URL"><strong>33 captures</strong></a>
           <div style="margin:0!important;padding:0!important;color:#666;font-size:9px;padding-top:2px!important;white-space:nowrap;" title="Timespan for captures of this URL">16 May 06 - 15 Feb 13</div>
       </td>
       <td style="padding:0!important;">
       <a style="position:relative; white-space:nowrap; width:450px;height:27px;" href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" style="position:relative; white-space:nowrap; width:450px;height:27px;background-color:#fff;cursor:pointer;border-right:1px solid #ccc;" title="Explore captures for this URL">
			<img id="sparklineImgId" style="position:absolute; z-index:9012; top:0px; left:0px;"
				onmouseover="showTrackers('inline');" 
				onmouseout="showTrackers('none');"
				onmousemove="trackMouseMove(event,this)"
				alt="sparklines"
				width="450"
				height="27"
				border="0"
				src="/web/jsp/graph.jsp?graphdata=450_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000010000100_2007:-1:000000000000_2008:-1:000010000000_2009:-1:000000000000_2010:-1:000000000010_2011:-1:000000020000_2012:0:3000c000a100_2013:-1:010000000000"></img>
			<img id="wbMouseTrackYearImg" 
				style="display:none; position:absolute; z-index:9010;"
				width="25" 
				height="27"
				border="0"
				src="/static/images/toolbar/transp-yellow-pixel.png"></img>
			<img id="wbMouseTrackMonthImg"
				style="display:none; position:absolute; z-index:9011; " 
				width="2"
				height="27" 
				border="0"
				src="/static/images/toolbar/transp-red-pixel.png"></img>
       </div>
		</a>

       </td>
       </tr></tbody></table>
   </td>
   <td style="text-align:right;padding:5px;width:65px;font-size:11px!important;">
       <a href="javascript:;" onclick="document.getElementById('wm-ipp').style.display='none';" style="display:block;padding-right:18px;background:url(/static/images/toolbar/wm_tb_close.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;margin-bottom:23px;background-color:transparent;border:none;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="display:block;padding-right:18px;background:url(/static/images/toolbar/wm_tb_help.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;background-color:transparent;border:none;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>

</div>
</div>
<script type="text/javascript">
 var wmDisclaimBanner = document.getElementById("wm-ipp");
 if(wmDisclaimBanner != null) {
   disclaimElement(wmDisclaimBanner);
 }
</script>
<!-- END WAYBACK TOOLBAR INSERT -->

	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Amazing Mazes (#31)</span>
			<p>by Matt Linnell</p>
			<p>We've had crosswords, cryptograms, chess puzzles, madlibs ... so why don't we try our hand at mazes?  We can define the two basic components of this problem as:</p>
			<p class="example">- Generating the maze<br />- Solving the maze</p>
			<p>* Generating the maze *</p>
			<p>The maze is to be rectangular in shape, with the height and width determined at run time.  All nodes of the maze must be reachable from any point.  In other words, if one were to randomly pick a start/stop, the maze is always solvable.  Furthermore, let us enforce that only 1 viable solution for the maze exists for any given start/stop (you cannot reach the same destination from 2 different routes).  Generate an ASCII output representing the maze.</p>
			<p>* Solving the Maze *</p>
			<p>Given a maze produced from your above code, find the solution.  Produce ASCII output to demonstrate/visualize solution.</p>
			<p>* Bonus Points *</p>
			<p class="example">1) Calculate which pair of start/stop points in the maze which gives<br />   you the longest possible path.<br />2) Calculate which pair of start/stop points in the maze which gives<br />   the most complicated path (involves the most turns)</p>
			<p>Example command line execution:</p>
			<p class="example">$&gt; ruby maze.rb {height} {width} [ {start} {stop} ]</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p>Wow, these solutions are great fun to play with.  I think next week's quiz needs to give me a little man icon and some controls!  Throw in some doors, some keys, and little critters to chase me around and there's simply no chance at all I would get a summary written next week.  Hmm, maybe it's not such a good idea.</p>
			<p>Jokes aside, do run the solutions a few times each this week.  It's fun to see what they build.  Then peek inside the code and read the comments.  Good stuff in there.</p>
			<p>Below, I want to look into Dominik Bathon's code.  It is a nice search and lightning quick!  On my machine, it makes and solves quizzes faster than the other solutions can just make them.  Even better, it uses a complex internal representation (mainly for speed), yet still comes out with clean algorithms.  I was quite impressed by that.</p>
			<p>Let's get to the code.  Dominik starts off by defining a helper method in Hash:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">class</span> Hash<br />          <span class="comment"># find the key for with the smallest value, delete it and return it</span><br />          <span class="keyword">def</span> delete_min_value<br />                <span class="keyword">return</span> <span class="keyword">nil</span> <span class="keyword">if</span> empty?<br />                minkey=min=<span class="keyword">nil</span><br />                each { |k, v|<br />                      min, minkey=v, k <span class="keyword">if</span> !min || v&lt;min<br />                }<br />                delete(minkey)<br />                minkey<br />          <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>The comment pretty much explains what's going on there.  Each pair of the Hash is compared by value.  The pair with the lowest value is deleted and the key for that value is returned.</p>
			<p>On to the interesting parts.  Here's the start of the main class used by the solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># Maze represents the maze ;-)</span><br />    <span class="comment">#</span><br />    <span class="comment"># Cells/positions in the maze are represented by Numbers</span><br />    <span class="comment"># (from 0 to w*h-1), each position corresponds to x/y coordinates,</span><br />    <span class="comment"># you can convert between positions and coordinates by coord2pos</span><br />    <span class="comment"># and pos2coord.</span><br />    <span class="comment">#</span><br />    <span class="comment"># The walls for each position are stored in the String @data. The walls</span><br />    <span class="comment"># for position p are stored in the first two bits of @data[p], the</span><br />    <span class="comment"># other bits are unused. If bit one is set then p has a north wall, if</span><br />    <span class="comment"># bit two is set then p has a west wall.</span><br />    <span class="comment">#</span><br />    <span class="comment"># Maze#generate generates a (random) maze using the method described at</span><br />    <span class="comment"># http://www.mazeworks.com/mazegen/mazetut/</span><br />    <span class="comment">#</span><br />    <span class="comment"># Maze#shortest_path uses Dijkstra's shortest path algorithm, so it can</span><br />    <span class="comment"># not anly find shortest pathes in perfect mazes, but also in mazes</span><br />    <span class="comment"># where different pathes between two position exist.</span><br /><br />    <span class="keyword">class</span> Maze<br />          attr_reader :w, :h <span class="comment"># width, height</span><br /><br />          <span class="keyword">def</span> initialize(w, h)<br />                <span class="variable">@w</span>, <span class="variable">@h</span>=[w, 1].max, [h, 1].max<br />                <span class="variable">@wh</span>=<span class="variable">@w</span>*<span class="variable">@h</span><br />                <span class="variable">@neighbors_cache</span>={}<br />                set_all_walls<br />          <span class="keyword">end</span><br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>I know that section is mostly a comment, but you'll want to read through it.  It's interesting information and it introduces you to the internal format the code uses.</p>
			<p>After that, we see some readers defined and some simple initialization work.  Set a width and height, ensuring they are both at least 1.  Nice use of max() there.  Calculate width times height or the total number of cells, initialize a cache and call set_all_walls().</p>
			<p>That means we need some more code:</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># ...</span><br /><br />          <span class="keyword">def</span> set_all_walls<br />                <span class="comment"># set all bits</span><br />                <span class="variable">@data</span>=3.chr * (<span class="variable">@wh</span>)<br />                <span class="keyword">nil</span><br />          <span class="keyword">end</span><br />          <span class="keyword">def</span> clear_all_walls<br />                <span class="comment"># all except outer border</span><br />                <span class="variable">@data</span>=0.chr * (<span class="variable">@wh</span>)<br />                <span class="comment"># set north walls of row 0</span><br />                w.times { |i| <span class="variable">@data</span>[i] |= 1 }<br />                <span class="comment"># set west walls of col 0</span><br />                h.times { |i| <span class="variable">@data</span>[i*w] |= 2 }<br />                <span class="keyword">nil</span><br />          <span class="keyword">end</span><br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>Okay, now we start to get tricky.  Remember the initial comment about using bits for the walls.  We're only tracking two walls here, north and west.  Of course cells can still have up to four walls, but your east wall is just your neighbor's west wall and your south wall is the north wall for the cell below you.</p>
			<p>Now, what do you get if you turn two bits on?  3.  The set_all_walls() method just translates that to a character and duplicates it for every cell.  That gives us a String representing the entire maze with all the walls turned on.</p>
			<p>That should make clear_all_walls() more obvious.  This time we want no walls so we don't set any bits.  Translate 0 to a character and duplicate.  However, we still need the edges of the maze.  All cells in the top row need a north wall (set the 1 bit).  Then all the cells in the first column need a west wall (set the 2 bit).  That makes up the rest of the method.</p>
			<p>Ready for the next chunk?</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># ...</span><br /><br />          <span class="comment"># positions in path will be printed as "X"</span><br />          <span class="keyword">def</span> to_s(path=[])<br />                ph={}<br />                path.each { |i| ph[i]=<span class="keyword">true</span> }<br />                res=<span class="string">""</span><br />                h.times { |y|<br />                      w.times { |x|<br />                            res &lt;&lt; <span class="string">"+"</span> &lt;&lt; ( (<span class="variable">@data</span>[y*w+x] &amp; 1 &gt; 0) ? <span class="string">"---"</span> :<br />                                                                     <span class="string">"   "</span> )<br />                      }<br />                      res &lt;&lt; <span class="string">"+\n"</span><br />                      w.times { |x|<br />                            res &lt;&lt; ((<span class="variable">@data</span>[y*w+x] &amp; 2 &gt; 0) ? <span class="string">"|"</span> : <span class="string">" "</span>)<br />                            res &lt;&lt; (ph[y*w+x] ? <span class="string">" X "</span> : <span class="string">"   "</span>)<br />                      }<br />                      res &lt;&lt; <span class="string">"|\n"</span><br />                }<br />                res &lt;&lt; (<span class="string">"+---"</span>*w) &lt;&lt; <span class="string">"+"</span><br />          <span class="keyword">end</span><br />          <span class="keyword">def</span> inspect<br />                <span class="string">"#&lt;#{self.class.name} #{w}x#{h}&gt;"</span><br />          <span class="keyword">end</span><br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>The to_s() method draws mazes.  The first two lines fill a Hash with the solution path, if one is given.  The Hash is indexed identically as the maze String and values can be true (if it's on the path) or the default nil, (when it's not).</p>
			<p>The rest of that method does the drawing.  It walks row by row with h.times(), down the maze drawing cells.  The first w.times() call handles the north walls.  First it adds a "+", then it adds "---" if the 1 bit is set or "&nbsp;&nbsp;&nbsp;" if it's  not.  Next we need another "+" and a "\n".  Now the second w.times() block handles the west wall and path.  First it checks to see if the 2 bit is set for the current cell, outputting "|" if it is and " " if it's not.  Then the path is checked.  If this cell is on the path, it's filled with " X " and if it's not, the code adds a "&nbsp;&nbsp;&nbsp;".</p>
			<p>The last two lines of the method are important.  They ensure a final "|" is always added to the end of a row and a final "+---" is placed at the end each column of the maze.  This handles the east and south borders of the maze, which are not covered by the bits.</p>
			<p>The other method, inspect(), just returns a class name, width and height.</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># ...</span><br /><br />          <span class="comment"># maze positions are cell indices from 0 to w*h-1</span><br />          <span class="comment"># the following functions do conversions to and from coordinates</span><br />          <span class="keyword">def</span> coord2pos(x, y)<br />                (y % h)*w+(x % w)<br />          <span class="keyword">end</span><br />          <span class="keyword">def</span> pos2coord(p)<br />                [p % w, (p/w) % h]<br />          <span class="keyword">end</span><br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>These convertors were explained in the initial comment and they are explained again here.  No surprises there.</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># returns valid neighbors to p, doesn't care about walls</span><br />          <span class="keyword">def</span> neighbors(p)<br />                <span class="keyword">if</span> ce=<span class="variable">@neighbors_cache</span>[p]; <span class="keyword">return</span> ce; <span class="keyword">end</span><br />                res=[p-w, p+w]<br />                res &lt;&lt; p-1 <span class="keyword">if</span> p%w &gt; 0<br />                res &lt;&lt; p+1 <span class="keyword">if</span> p%w &lt; w-1<br />                <span class="variable">@neighbors_cache</span>[p] = res.find_all { |t| t&gt;=0 &amp;&amp; t&lt;<span class="variable">@wh</span> }<br />          <span class="keyword">end</span><br /><br /></div></div>
			<p>This returns the indices of the up to four neighboring cells.  It caches this lookup the first time it does it, since it will never change.  The first line just uses the cache if it has already been figured.  The second line adds the cell above and the cell below.  Note that these numbers are found by simple math and could be outside the bounds of the maze.  The next two lines add the left and right cells.  We're more careful with our math here, because a wrong answer could look right:  The last cell of the first row is "left" of the first cell of the second row, in our one dimensional String that holds the maze data.  The final line, stores the indices to the cache and returns them, after using find_all() to eliminate any bogus number that crept in.</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># ...</span><br /><br />          <span class="keyword">def</span> wall_between?(p1, p2)<br />                p1, p2=[p1, p2].sort<br />                <span class="keyword">if</span> p2-p1==w <span class="comment"># check north wall of p2</span><br />                      <span class="variable">@data</span>[p2] &amp; 1 &gt; 0<br />                <span class="keyword">elsif</span> p2-p1==1 <span class="comment"># check west wall of p2</span><br />                      <span class="variable">@data</span>[p2] &amp; 2 &gt; 0<br />                <span class="keyword">else</span><br />                      <span class="keyword">false</span><br />                <span class="keyword">end</span><br />          <span class="keyword">end</span><br />          <span class="keyword">def</span> set_wall(p1, p2)<br />                p1, p2=[p1, p2].sort<br />                <span class="keyword">if</span> p2-p1==w <span class="comment"># set north wall of p2</span><br />                      <span class="variable">@data</span>[p2] |= 1<br />                <span class="keyword">elsif</span> p2-p1==1 <span class="comment"># set west wall of p2</span><br />                      <span class="variable">@data</span>[p2] |= 2<br />                <span class="keyword">end</span><br />                <span class="keyword">nil</span><br />          <span class="keyword">end</span><br />          <span class="keyword">def</span> unset_wall(p1, p2)<br />                p1, p2=[p1, p2].sort<br />                <span class="keyword">if</span> p2-p1==w <span class="comment"># unset north wall of p2</span><br />                      <span class="variable">@data</span>[p2] &amp;= ~1<br />                <span class="keyword">elsif</span> p2-p1==1 <span class="comment"># unset west wall of p2</span><br />                      <span class="variable">@data</span>[p2] &amp;= ~2<br />                <span class="keyword">end</span><br />                <span class="keyword">nil</span><br />          <span class="keyword">end</span><br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>These three methods are all very similar.  Given two cells, the first checks if there is a wall between them, the second sets the wall between them, and the third unsets it.  The if's just figure out if we are talking about a north wall or a west wall.  The rest is bit testing or setting.</p>
			<p>On to maze generation:</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># ...</span><br /><br />          <span class="comment"># generate a (random) perfect maze</span><br />          <span class="keyword">def</span> generate(random=<span class="keyword">true</span>)<br />                set_all_walls<br />                <span class="comment"># (random) depth first search method</span><br />                visited={0 =&gt; <span class="keyword">true</span>}<br />                stack=[0]<br />                <span class="keyword">until</span> stack.empty?<br />                      n=neighbors(stack.last).reject { |p| visited[p] }<br />                      <span class="keyword">if</span> n.empty?<br />                            stack.pop<br />                      <span class="keyword">else</span><br />                            <span class="comment"># choose one unvisited neighbor</span><br />                            np=n[random ? rand(n.size) : 0]<br />                            unset_wall(stack.last, np)<br />                            visited[np]=<span class="keyword">true</span><br />                            <span class="comment"># if all neighbors are visited then here is</span><br />                            <span class="comment"># nothing left to do</span><br />                            stack.pop <span class="keyword">if</span> n.size==1<br />                            stack.push np<br />                      <span class="keyword">end</span><br />                <span class="keyword">end</span><br />                <span class="keyword">self</span><br />          <span class="keyword">end</span><br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>This algorithm came out very clean, I think.  Not a bit operation in sight.  First it turns all the walls on.  Then it sets up an Array for tracking visited cells and another as a stack to drive the process.  While there is something on the stack, the code looks at each not-yet-visited neighbor.  If there are no neighbors in that set, the stack is popped and the routine moves on.  However, if there are, one is chosen at random and the wall is knocked out between them.  If that neighbor was the last unvisited one for this cell, the code pops the current cell off the stack.  The neighbor cell is set to visited and pushed onto the stack, moving the build process to that location for the next iteration.</p>
			<p>That covers creation.  Now we need a solver:</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># ...</span><br /><br />          <span class="comment"># central part of Dijkstra's shortest path algorithm:</span><br />          <span class="comment"># returns a hash that associates each reachable (from start)</span><br />          <span class="comment"># position p, with the previous position on the shortest path</span><br />          <span class="comment"># from start to p and the length of that path.</span><br />          <span class="comment"># example: if the shortest path from 0 to 2 is [0, 1, 2], then</span><br />          <span class="comment"># prev[2]==[1, 2], prev[1]==[0, 1] and prev[0]==[nil, 0].</span><br />          <span class="comment"># so you can get all shortest paths from start to each reachable</span><br />          <span class="comment"># position out of the returned hash.</span><br />          <span class="comment"># if stop_at!=nil the method stops when the previous cell on the</span><br />          <span class="comment"># shortest path from start to stop_at is found.</span><br />          <span class="keyword">def</span> build_prev_hash(start, stop_at=<span class="keyword">nil</span>)<br />                prev={start=&gt;[<span class="keyword">nil</span>, 0]} <span class="comment"># hash to be returned</span><br />                <span class="keyword">return</span> prev <span class="keyword">if</span> stop_at==start<br />                <span class="comment"># positions which we have seen, but we are not yet sure about</span><br />                <span class="comment"># the shortest path to them (the value is length of the path,</span><br />                <span class="comment"># for delete_min_value):</span><br />                active={start=&gt;0}<br />                <span class="keyword">until</span> active.empty?<br />                      <span class="comment"># get the position with the shortest path from the</span><br />                      <span class="comment"># active list</span><br />                      cur=active.delete_min_value<br />                      <span class="keyword">return</span> prev <span class="keyword">if</span> cur==stop_at<br />                      newlength=prev[cur][1]+1 <span class="comment"># path to cur length + 1</span><br />                      <span class="comment"># for all reachable neighbors of cur, check if we found</span><br />                      <span class="comment"># a shorter path to them</span><br />                      neighbors(cur).each { |n|<br />                            <span class="comment"># ignore unreachable</span><br />                            <span class="keyword">next</span> <span class="keyword">if</span> wall_between?(cur, n)<br />                            <span class="keyword">if</span> old=prev[n] <span class="comment"># was n already visited</span><br />                                  <span class="comment"># if we found a longer path, ignore it</span><br />                                  <span class="keyword">next</span> <span class="keyword">if</span> newlength&gt;=old[1]<br />                            <span class="keyword">end</span><br />                            <span class="comment"># (re)add new position to active list</span><br />                            active[n]=newlength<br />                            <span class="comment"># set new prev and length</span><br />                            prev[n]=[cur, newlength]<br />                      }<br />                <span class="keyword">end</span><br />                prev<br />          <span class="keyword">end</span><br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>I really don't think I need to launch into too deep an explanation here as the comments guide you right through it.  The short story is that this method branches out from a starting cell, walking to each neighbor and always counting its steps.  While doing this, it is building the Hash described in the first comment, which points to the cell that came before on the shortest path.  Using that Hash, returned by this method, you can easily construct the shortest path to any cell the algorithm visited.  Handy stuff!  Let's see how it gets put to use:</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># ...</span><br /><br />          <span class="keyword">def</span> shortest_path(from, to)<br />                prev=build_prev_hash(from, to)<br />                <span class="keyword">if</span> prev[to]<br />                      <span class="comment"># path found, build it by following the prev hash from</span><br />                      <span class="comment"># "to" to "from"</span><br />                      path=[to]<br />                      path.unshift(to) <span class="keyword">while</span> to=prev[to][0]<br />                      path<br />                <span class="keyword">else</span><br />                      <span class="keyword">nil</span><br />                <span class="keyword">end</span><br />          <span class="keyword">end</span><br /><br />          <span class="comment"># ...</span><br /><br /></div></div>
			<p>Given a starting and ending cell, this returns just what the name implies.  It builds the magic Hash we just looked at on the first line, then just walks the path in reverse until it reaches the start (nil in the Hash).  Again, clean and simple.  Nice coding Dominik.</p>
			<p>Let's look at the other search the code provides:</p>
			<div class="code"><span class="type">ruby</span><div class="body">          <span class="comment"># ...</span><br /><br />          <span class="comment"># finds the longest shortest path in this maze, only works if</span><br />          <span class="comment"># there is at least one position that can only reach one</span><br />          <span class="comment"># neighbor, because we search only starting at those positions.</span><br />          <span class="keyword">def</span> longest_shortest_path<br />                startp=endp=<span class="keyword">nil</span><br />                max=-1<br />                <span class="variable">@wh</span>.times { |p|<br />                      <span class="comment"># if current p can only reach 1 neighbor</span><br />                      <span class="keyword">if</span> neighbors(p).reject { |n|<br />                               wall_between?(p, n)<br />                         }.size==1<br />                            prev=build_prev_hash(p)<br />                            <span class="comment"># search longest path from p</span><br />                            tend, tmax=<span class="keyword">nil</span>, -1<br />                            prev.each { |k, v|<br />                                  <span class="keyword">if</span> v[1]&gt;tmax<br />                                        tend=k<br />                                        tmax=v[1]<br />                                  <span class="keyword">end</span><br />                            }<br />                            <span class="keyword">if</span> tmax&gt;max<br />                                  max=tmax<br />                                  startp, endp=p, tend<br />                            <span class="keyword">end</span><br />                      <span class="keyword">end</span><br />                }<br />                <span class="keyword">if</span> startp <span class="comment"># path found</span><br />                      shortest_path(startp, endp)<br />                <span class="keyword">else</span><br />                      <span class="keyword">nil</span><br />                <span class="keyword">end</span><br />          <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This method walks the maze, looking for cells that are dead-ends.  From each of those, it builds the path Hash and checks the lengths of each path found.  In the end, it will return the longest path it saw.</p>
			<p>Just a little more code is needed for human interface:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">if</span> <span class="global">$0</span> == <span class="keyword">__FILE__</span><br />          ARGV.shift <span class="keyword">if</span> search_longest=ARGV[0]==<span class="string">"-l"</span><br />          w, h, from, to=ARGV<br />          m=Maze.new(w.to_i, h.to_i)<br />          m.generate<br />          puts <span class="string">"Maze:"</span>, m.to_s<br />          <span class="keyword">if</span> from=~<span class="string">/(\d+),(\d+)/</span><br />                p1=m.coord2pos(<span class="global">$1</span>.to_i, <span class="global">$2</span>.to_i)<br />          <span class="keyword">else</span><br />                p1=rand(m.w*m.h)<br />          <span class="keyword">end</span><br />          <span class="keyword">if</span> to=~<span class="string">/(\d+),(\d+)/</span><br />                p2=m.coord2pos(<span class="global">$1</span>.to_i, <span class="global">$2</span>.to_i)<br />          <span class="keyword">else</span><br />                p2=rand(m.w*m.h)<br />          <span class="keyword">end</span><br /><br />          path=m.shortest_path(p1, p2)<br />          puts <span class="string">"\nShortest path from #{m.pos2coord(p1).inspect} to "</span> \<br />          <span class="string">"#{m.pos2coord(p2).inspect}:"</span>, m.to_s(path)<br /><br />          <span class="keyword">if</span> search_longest<br />                path=m.longest_shortest_path<br />                puts <span class="string">"\nLongest shortest path (from "</span> \<br />                <span class="string">"#{m.pos2coord(path[0]).inspect} to "</span> \<br />                <span class="string">"#{m.pos2coord(path[-1]).inspect}:"</span>,<br />                m.to_s(path)<br />          <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>This is just option parsing and display.  The code checks for a special first "-l" option, which just sets a flag to add the long search.</p>
			<p>The next chunk reads a width and height then builds and displays a maze of the indicated size.   The code next reads from and to cells for a solution search, if they where provided.  Random coordinates are used when from or to cells are absent.  Note the use of the coord2pos() convertor in here.</p>
			<p>Finally, the shortest path is displayed.  The longer search is also added, if requested.  Dominik uses an unusual Ruby idiom here, "string" "string".  Ruby will concatenate these, even without the + between them.  (I didn't know this!)  However, the rumor is that this feature may vanish in a future version of Ruby, so it's probably not a good habit to get into.</p>
			<p>My thanks to those who braved the mazes this week.  Really interesting (and fun!) solutions were given by all.</p>
			<p>Tomorrow's quiz is a little client and server fun, care of Pat Eyler's children...</p>
		</div>
		<div id="logo"><img src="/web/20120121210115im_/http://rubyquiz.com/images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="/web/20120121210115/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/141692">Brian Schr&ouml;der</a></li>
				<li><a href="/web/20120121210115/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/141783">Dominik Bathon</a></li>
				<li><a href="/web/20120121210115/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/141901">Markus Koenig</a></li>
				<li><a href="/web/20120121210115/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/142366">Dave Burt</a></li>
				<li><a href="/web/20120121210115/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/143012">Glenn M. Lewis</a></li>
				<li><a href="/web/20120121210115/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/143270">Glenn M. Lewis (2)</a></li>
			</ol>
			<p><a href="/web/20120121210115/http://rubyquiz.com/quiz31_sols.zip">Download Solutions</a></p>
			<p><a href="/web/20120121210115/http://rubyquiz.com/index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>





<!--
     FILE ARCHIVED ON 21:01:15 Jan 21, 2012 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 13:09:26 Jun 5, 2013.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
