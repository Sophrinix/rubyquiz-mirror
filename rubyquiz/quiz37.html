<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>


<!-- Start Wayback Rewrite JS Include -->
<script type="text/javascript" src="/static/js/jwplayer/jwplayer.js" ></script>
<script type="text/javascript" src="/static/js/video-embed-rewriter.js"></script>
<script type="text/javascript">
function initYTVideo(id)
{
	_wmVideos_.init("/web/", id);
}
</script>
<!-- End Wayback Rewrite JS Include -->

	<title>Ruby Quiz - Inference Engine (#37)</title>
	<link rel="stylesheet" type="text/css" href="/web/20120121210633cs_/http://rubyquiz.com/quiz.css" />
	<link rel="stylesheet" type="text/css" href="/web/20120121210633cs_/http://rubyquiz.com/print.css" media="print" />
</head><body>
<!-- BEGIN WAYBACK TOOLBAR INSERT -->

<script type="text/javascript" src="/static/js/disclaim-element.js" ></script>
<script type="text/javascript" src="/static/js/graph-calc.js" ></script>
<script type="text/javascript" src="/static/jflot/jquery.min.js" ></script>
<script type="text/javascript">
//<![CDATA[
var firstDate = 820454400000;
var lastDate = 1388534399999;
var wbPrefix = "/web/";
var wbCurrentUrl = "http:\/\/rubyquiz.com\/quiz37.html";

var curYear = -1;
var curMonth = -1;
var yearCount = 18;
var firstYear = 1996;
var imgWidth = 450;
var yearImgWidth = 25;
var monthImgWidth = 2;
var trackerVal = "none";
var displayDay = "21";
var displayMonth = "Jan";
var displayYear = "2012";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

function showTrackers(val) {
	if(val == trackerVal) {
		return;
	}
	if(val == "inline") {
		document.getElementById("displayYearEl").style.color = "#ec008c";
		document.getElementById("displayMonthEl").style.color = "#ec008c";
		document.getElementById("displayDayEl").style.color = "#ec008c";		
	} else {
		document.getElementById("displayYearEl").innerHTML = displayYear;
		document.getElementById("displayYearEl").style.color = "#ff0";
		document.getElementById("displayMonthEl").innerHTML = displayMonth;
		document.getElementById("displayMonthEl").style.color = "#ff0";
		document.getElementById("displayDayEl").innerHTML = displayDay;
		document.getElementById("displayDayEl").style.color = "#ff0";
	}
   document.getElementById("wbMouseTrackYearImg").style.display = val;
   document.getElementById("wbMouseTrackMonthImg").style.display = val;
   trackerVal = val;
}
function getElementX2(obj) {
	var thing = jQuery(obj);
	if((thing == undefined) 
			|| (typeof thing == "undefined") 
			|| (typeof thing.offset == "undefined")) {
		return getElementX(obj);
	}
	return Math.round(thing.offset().left);
}
function trackMouseMove(event,element) {

   var eventX = getEventX(event);
   var elementX = getElementX2(element);
   var xOff = eventX - elementX;
	if(xOff < 0) {
		xOff = 0;
	} else if(xOff > imgWidth) {
		xOff = imgWidth;
	}
   var monthOff = xOff % yearImgWidth;

   var year = Math.floor(xOff / yearImgWidth);
	var yearStart = year * yearImgWidth;
   var monthOfYear = Math.floor(monthOff / monthImgWidth);
   if(monthOfYear > 11) {
       monthOfYear = 11;
   }
   // 1 extra border pixel at the left edge of the year:
   var month = (year * 12) + monthOfYear;
   var day = 1;
	if(monthOff % 2 == 1) {
		day = 15;
	}
	var dateString = 
		zeroPad(year + firstYear) + 
		zeroPad(monthOfYear+1,2) +
		zeroPad(day,2) + "000000";

	var monthString = prettyMonths[monthOfYear];
	document.getElementById("displayYearEl").innerHTML = year + 1996;
	document.getElementById("displayMonthEl").innerHTML = monthString;
	// looks too jarring when it changes..
	//document.getElementById("displayDayEl").innerHTML = zeroPad(day,2);

	var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
	document.getElementById('wm-graph-anchor').href = url;

   //document.getElementById("wmtbURL").value="evX("+eventX+") elX("+elementX+") xO("+xOff+") y("+year+") m("+month+") monthOff("+monthOff+") DS("+dateString+") Moy("+monthOfYear+") ms("+monthString+")";
   if(curYear != year) {
       var yrOff = year * yearImgWidth;
       document.getElementById("wbMouseTrackYearImg").style.left = yrOff + "px";
       curYear = year;
   }
   if(curMonth != month) {
       var mtOff = year + (month * monthImgWidth) + 1;
       document.getElementById("wbMouseTrackMonthImg").style.left = mtOff + "px";
       curMonth = month;
   }
}
//]]>
</script>

<style type="text/css">body{margin-top:0!important;padding-top:0!important;min-width:800px!important;}#wm-ipp a:hover{text-decoration:underline!important;}</style>
<div id="wm-ipp" style="display:none; position:relative;padding:0 5px;min-height:70px;min-width:800px; z-index:9000;">
<div id="wm-ipp-inside" style="position:fixed;padding:0!important;margin:0!important;width:97%;min-width:780px;border:5px solid #000;border-top:none;background-image:url(/static/images/toolbar/wm_tb_bk_trns.png);text-align:center;-moz-box-shadow:1px 1px 3px #333;-webkit-box-shadow:1px 1px 3px #333;box-shadow:1px 1px 3px #333;font-size:11px!important;font-family:'Lucida Grande','Arial',sans-serif!important;">
   <table style="border-collapse:collapse;margin:0;padding:0;width:100%;"><tbody><tr>
   <td style="padding:10px;vertical-align:top;min-width:110px;">
   <a href="/web/" title="Wayback Machine home page" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0"/></a>
   </td>
   <td style="padding:0!important;text-align:center;vertical-align:top;width:100%;">

       <table style="border-collapse:collapse;margin:0 auto;padding:0;width:570px;"><tbody><tr>
       <td style="padding:3px 0;" colspan="2">
       <form target="_top" method="get" action="/web/form-submit.jsp" name="wmtb" id="wmtb" style="margin:0!important;padding:0!important;"><input type="text" name="url" id="wmtbURL" value="http://rubyquiz.com/quiz37.html" style="width:400px;font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;" onfocus="javascript:this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20120121210633" /><input type="submit" value="Go" style="font-size:11px;font-family:'Lucida Grande','Arial',sans-serif;margin-left:5px;" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td style="vertical-align:bottom;padding:5px 0 0 0!important;" rowspan="2">
           <table style="border-collapse:collapse;width:110px;color:#99a;font-family:'Helvetica','Lucida Grande','Arial',sans-serif;"><tbody>
			
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr style="width:110px;height:16px;font-size:10px!important;">
           	<td style="padding-right:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20101127172502/http://rubyquiz.com/quiz37.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="27 Nov 2010"><strong>NOV</strong></a>
		                
               </td>
               <td id="displayMonthEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight:bold;text-transform:uppercase;width:34px;height:15px;padding-top:1px;text-align:center;" title="You are here: 21:06:33 Jan 21, 2012">JAN</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight:bold;text-transform:uppercase;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20120418150853/http://www.rubyquiz.com/quiz37.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="18 Apr 2012"><strong>APR</strong></a>
		                
               </td>
           </tr>

           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr>
               <td style="padding-right:9px;white-space:nowrap;overflow:visible;text-align:right!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="/web/20101127172502/http://rubyquiz.com/quiz37.html" title="17:25:02 Nov 27, 2010" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
		                
               </td>
               <td id="displayDayEl" style="background:#000;color:#ff0;width:34px;height:24px;padding:2px 0 0 0;text-align:center;font-size:24px;font-weight: bold;" title="You are here: 21:06:33 Jan 21, 2012">21</td>
				<td style="padding-left:9px;white-space:nowrap;overflow:visible;text-align:left!important;vertical-align:middle!important;" nowrap="nowrap">
               
		                <a href="/web/20120418150853/http://www.rubyquiz.com/quiz37.html" title="15:08:53 Apr 18, 2012" style="background-color:transparent;border:none;"><img src="/static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"/></a>
		                
			    </td>
           </tr>

           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr style="width:110px;height:13px;font-size:9px!important;">
				<td style="padding-right:9px;font-size:11px!important;font-weight: bold;text-align:right;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20101127172502/http://rubyquiz.com/quiz37.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="27 Nov 2010"><strong>2010</strong></a>
		                
               </td>
               <td id="displayYearEl" style="background:#000;color:#ff0;font-size:11px!important;font-weight: bold;padding-top:1px;width:34px;height:13px;text-align:center;" title="You are here: 21:06:33 Jan 21, 2012">2012</td>
				<td style="padding-left:9px;font-size:11px!important;font-weight: bold;white-space:nowrap;overflow:visible;" nowrap="nowrap">
               
		                <a href="/web/20130215052308/http://rubyquiz.com/quiz37.html" style="text-decoration:none;color:#33f;font-weight:bold;background-color:transparent;border:none;" title="15 Feb 2013"><strong>2013</strong></a>
		                
				</td>
           </tr>
           </tbody></table>
       </td>

       </tr>
       <tr>
       <td style="vertical-align:middle;padding:0!important;">
           <a href="/web/20120121210633*/http://rubyquiz.com/quiz37.html" style="color:#33f;font-size:11px;font-weight:bold;background-color:transparent;border:none;" title="See a list of every capture for this URL"><strong>28 captures</strong></a>
           <div style="margin:0!important;padding:0!important;color:#666;font-size:9px;padding-top:2px!important;white-space:nowrap;" title="Timespan for captures of this URL">16 May 06 - 15 Feb 13</div>
       </td>
       <td style="padding:0!important;">
       <a style="position:relative; white-space:nowrap; width:450px;height:27px;" href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" style="position:relative; white-space:nowrap; width:450px;height:27px;background-color:#fff;cursor:pointer;border-right:1px solid #ccc;" title="Explore captures for this URL">
			<img id="sparklineImgId" style="position:absolute; z-index:9012; top:0px; left:0px;"
				onmouseover="showTrackers('inline');" 
				onmouseout="showTrackers('none');"
				onmousemove="trackMouseMove(event,this)"
				alt="sparklines"
				width="450"
				height="27"
				border="0"
				src="/web/jsp/graph.jsp?graphdata=450_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000010000100_2007:-1:000100100000_2008:-1:000020000000_2009:-1:000000000000_2010:-1:100000000010_2011:-1:000000000000_2012:0:10016000a100_2013:-1:010000000000"></img>
			<img id="wbMouseTrackYearImg" 
				style="display:none; position:absolute; z-index:9010;"
				width="25" 
				height="27"
				border="0"
				src="/static/images/toolbar/transp-yellow-pixel.png"></img>
			<img id="wbMouseTrackMonthImg"
				style="display:none; position:absolute; z-index:9011; " 
				width="2"
				height="27" 
				border="0"
				src="/static/images/toolbar/transp-red-pixel.png"></img>
       </div>
		</a>

       </td>
       </tr></tbody></table>
   </td>
   <td style="text-align:right;padding:5px;width:65px;font-size:11px!important;">
       <a href="javascript:;" onclick="document.getElementById('wm-ipp').style.display='none';" style="display:block;padding-right:18px;background:url(/static/images/toolbar/wm_tb_close.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;margin-bottom:23px;background-color:transparent;border:none;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="display:block;padding-right:18px;background:url(/static/images/toolbar/wm_tb_help.png) no-repeat 100% 0;color:#33f;font-family:'Lucida Grande','Arial',sans-serif;background-color:transparent;border:none;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>

</div>
</div>
<script type="text/javascript">
 var wmDisclaimBanner = document.getElementById("wm-ipp");
 if(wmDisclaimBanner != null) {
   disclaimElement(wmDisclaimBanner);
 }
</script>
<!-- END WAYBACK TOOLBAR INSERT -->

	<div id="page">
		<div id="header"><span class="ruby">Ruby</span> <span class="quiz">Quiz</span></div>
		<div id="content">
			<span class="title">Inference Engine (#37)</span>
			<p>There was an interesting thread on Ruby Talk recently about Truth Maintenance Systems (TMS).  One reason to use a TMS is to validate inferences, given certain truths.  We'll focus on that application here.</p>
			<p>This week's Ruby Quiz is to build an inference engine that is capable of answering questions based on the provided truths.</p>
			<p>Note that our Perl friends have already done this quiz, with their own Perl Quiz of the Week.  It was an interesting problem that generated good solutions and discussion.  Because of that, I'm going to copy the format used there, originally by Dan Sanderson and Mark Jason Dominus.</p>
			<p>You should be able to teach your engine truths with the following inputs:</p>
			<p class="example">All PLURAL-NOUN are PLURAL-NOUN.<br />No PLURAL-NOUN are PLURAL-NOUN.<br />Some PLURAL-NOUN are PLURAL-NOUN.<br />Some PLURAL-NOUN are not PLURAL-NOUN.</p>
			<p>You should also be able to query your engine with the following questions:</p>
			<p class="example">Are all PLURAL-NOUN PLURAL-NOUN?<br />Are no PLURAL-NOUN PLURAL-NOUN?<br />Are any PLURAL-NOUN PLURAL-NOUN?<br />Are any PLURAL-NOUN not PLURAL-NOUN?<br />Describe PLURAL-NOUN.</p>
			<p>Here's a sample run straight out of the Perl Quiz to show how all of this fits together:</p>
			<p class="example">&gt; All mammals are hairy animals.<br />OK.<br />&gt; All dogs are mammals.<br />OK.<br />&gt; All beagles are dogs.<br />OK.<br />&gt; Are all beagles hairy animals?<br />Yes, all beagles are hairy animals.<br />&gt; All cats are mammals.<br />OK.<br />&gt; All cats are hairy animals.<br />I know.<br />&gt; Are all cats dogs?<br />I don't know.<br />&gt; No cats are dogs.<br />OK.<br />&gt; Are all cats dogs?<br />No, not all cats are dogs.<br />&gt; Are no cats dogs?<br />Yes, no cats are dogs.<br />&gt; All mammals are dogs.<br />Sorry, that contradicts what I already know.<br />&gt; Some mammals are brown animals.<br />OK.<br />&gt; Are any mammals dogs?<br />Yes, some mammals are dogs.<br />&gt; Are any dogs brown animals?<br />I don't know.<br />&gt; Some dogs are brown animals.<br />OK.<br />&gt; All brown animals are brown things.<br />OK.<br />&gt; Are any dogs brown things?<br />Yes, some dogs are brown things.<br />&gt; Describe dogs.<br />All dogs are mammals.<br />All dogs are hairy animals.<br />No dogs are cats.<br />Some dogs are beagles.<br />Some dogs are brown animals.<br />Some dogs are brown things.<br />&gt; Are all goldfish mammals?<br />I don't know anything about goldfish.</p>
			<p>In the discussion of the Perl Quiz, some very interesting examples were posted.  Here's my favorite, which we'll call extra credit:</p>
			<p class="example">&gt; All dogs are mammals<br />OK.<br />&gt; No octopuses are mammals<br />OK.<br />&gt; Are any octopuses dogs?<br />I don't know.</p>
			<p>That's not the correct answer.  See how your engine answers that question.</p>
			<hr />
			<p><span class="title">Quiz Summary</span></p>
			<p class="example">irb(main):005:0&gt; are any programmers happy programmers?<br />=&gt; Yes, some programmers are happy programmers.<br />irb(main):006:0&gt; are all Ruby programmers happy programmers?<br />=&gt; Yes, all ruby programmers are happy programmers.<br />irb(main):007:0&gt; are any Python programmers happy programmers?<br />=&gt; I don't know.</p>
			<p>True artificial intelligence doesn't seem that far off after all.</p>
			<p>Did you know you could use irb as an interface like that?  I didn't!  Be sure and glance at Pit Capitain's code to see just how that is done.</p>
			<p>Daniel Sheppard sent in a nice object model, translating the rules into a class hierarchy.  I recommend browsing through that too.</p>
			<p>Here though, I want to look into Paulo Capriotti's code.  Paulo decided to model the relationships as a directed graph, where vertices are the groups and edges represent their relationships.  To save a little work, Paulo used the graph Ruby library as a starting point.  Here's the beginning of the solution:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    require <span class="string">'graph'</span><br /><br />    <span class="keyword">def</span> opposite_type(type)<br />      type == :provable_true ? :provable_false : :provable_true<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> Property<br />      attr_reader :name, :type<br />      <span class="keyword">def</span> initialize(name, type)<br />        <span class="variable">@name</span> = name<br />        <span class="variable">@type</span> = type<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> opposite<br />        Property.new(<span class="variable">@name</span>, <span class="variable">@type</span> == :positive ? :negative : :positive)<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> Property.create(x)<br />        <span class="keyword">if</span> x.respond_to?(:opposite)<br />          x<br />        <span class="keyword">else</span><br />          Property.new(x, :positive)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> hash<br />        <span class="string">"#{@name}##{@type}"</span>.hash<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> eql?(other)<br />        <span class="variable">@name</span> == other.name <span class="keyword">and</span> <span class="variable">@type</span> == other.type<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">alias</span> == eql?<br /><br />      <span class="keyword">def</span> to_s<br />        res = <span class="variable">@name</span><br />        <span class="keyword">if</span> <span class="variable">@type</span> == :negative<br />          <span class="string">"not-"</span> + res<br />        <span class="keyword">else</span><br />          res<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>First we see the definition of a simple helper method to convert between two opposites:  Things we can prove to be true and things we can prove are false.</p>
			<p>Next, we have a helper class for a Property.  I wasn't sure what that meant at first, so I had to dig a little.  Obviously, much of this class is just support for hashing the object (hash() and eql?()).  We have a class method to create() a Property when needed and an interesting method to give us an opposite() Property.  The to_s() method is also interesting.  We can see from it that a negated Property gets a leading "not-" when converted to a String.</p>
			<p>All of this clicked into place for me when I turned on Paulo's debug mode and watched the code work.  Here's an example:</p>
			<p class="example">&gt; All dogs are mammals<br />adding edge dog, not-dog, provable_false<br />adding edge not-dog, dog, provable_false<br />adding edge dog, dog, provable_true<br />adding edge not-dog, not-dog, provable_true<br />adding edge mammal, not-mammal, provable_false<br />adding edge not-mammal, mammal, provable_false<br />adding edge mammal, mammal, provable_true<br />adding edge not-mammal, not-mammal, provable_true<br />...<br />adding edge dog, mammal, provable_true<br />adding edge not-mammal, not-dog, provable_true<br />...<br />adding edge not-mammal, dog, provable_false<br />adding edge not-dog, mammal, provable_false<br />...<br />adding edge mammal, not-dog, provable_false<br />adding edge dog, not-mammal, provable_false<br />...</p>
			<p>As you can see, a Property is a representation of the groups we are describing to the inference engine.  Opposites represent everything not in that Property, or group.  So the "dog" Property has an opposite of "not-dog", or non-dog, if it's easier to think of that way.</p>
			<p>What's the rest of that stuff about edges and what we can prove though?  That's the graph being built, as I mentioned earlier.  Let's examine that code now:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    <span class="keyword">class</span> Knowledge &lt; DirectedHashGraph<br />      attr_reader :contradiction<br /><br />      <span class="keyword">def</span> initialize<br />        <span class="variable">@contradiction</span> = <span class="keyword">false</span><br />        <span class="keyword">super</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Add a property and some tautologies.</span><br />      <span class="comment"># Here we assume that the property and</span><br />      <span class="comment"># its opposite are not void.</span><br />      <span class="keyword">def</span> add_property(x)<br />        x = Property.create(x)<br />        safe_add_edge(x, x.opposite, :provable_false)<br />        safe_add_edge(x.opposite, x, :provable_false)<br />        safe_add_edge(x, x, :provable_true)<br />        safe_add_edge(x.opposite, x.opposite, :provable_true)<br />        x<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Add en edge. Never throw.</span><br />      <span class="keyword">def</span> safe_add_edge(x, y, type)<br />        catch(:add_edge_throw) <span class="keyword">do</span><br />          add_edge(x, y, type)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Add an edge. Throw if the edge already exists.</span><br />      <span class="keyword">def</span> add_edge(x, y, type)<br />        debug_msg <span class="string">"adding edge #{x}, #{y}, #{type}"</span><br />        <span class="keyword">if</span> <span class="keyword">self</span>[x,y]<br />          <span class="keyword">unless</span> <span class="keyword">self</span>[x,y] == type<br />            <span class="variable">@contradiction</span> = <span class="keyword">true</span><br />            debug_msg <span class="string">" \tcontradiction"</span><br />            throw :add_edge_throw, :contradiction<br />          <span class="keyword">else</span><br />            debug_msg <span class="string">"\ti know"</span><br />            throw :add_edge_throw, :i_know<br />          <span class="keyword">end</span><br />        <span class="keyword">else</span><br />          <span class="keyword">super</span>(x, y, type)<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Add an edge and its contrapositive.</span><br />      <span class="keyword">def</span> add_assertion(*args)<br />        x, y, type = get_stmt(*args)<br />        catch(:add_edge_throw) <span class="keyword">do</span><br />          add_edge(x, y, type)<br />          add_edge(y.opposite, x.opposite, type)<br />          :normal<br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Extract statement values.</span><br />      <span class="keyword">def</span> get_stmt(*args)<br />        <span class="keyword">case</span> args.size<br />        <span class="keyword">when</span> 1<br />          x, y, type = args[0].x, args[0].y, args[0].type<br />        <span class="keyword">when</span> 3<br />          x, y, type = args[0], args[1], args[2]<br />        <span class="keyword">else</span><br />          raise <span class="string">"Invalid argument list in #{caller.first}"</span><br />        <span class="keyword">end</span><br />        <span class="keyword">return</span> add_property(x), add_property(y), type<br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Discover all possible deductions</span><br />      <span class="comment"># and add the corresponding edges to the graph.</span><br />      <span class="keyword">def</span> deduce<br />        each_vertex <span class="keyword">do</span> |v1|<br />          each_vertex <span class="keyword">do</span> |v2|<br />            each_vertex <span class="keyword">do</span> |v3|<br /><br />              <span class="keyword">if</span> <span class="keyword">self</span>[v1,v2] == :provable_true <span class="keyword">and</span><br />                 <span class="keyword">self</span>[v2,v3] == :provable_true<br />                add_assertion(v1, v3, :provable_true)<br />              <span class="keyword">end</span><br /><br />              <span class="keyword">if</span> <span class="keyword">self</span>[v2,v1] == :provable_false <span class="keyword">and</span><br />                 <span class="keyword">self</span>[v2,v3] == :provable_true<br />                add_assertion(v3, v1, :provable_false)<br />              <span class="keyword">end</span><br /><br />              <span class="keyword">if</span> <span class="keyword">self</span>[v1,v2] == :provable_true <span class="keyword">and</span><br />                 <span class="keyword">self</span>[v3,v2] == :provable_false<br />                add_assertion(v3, v1, :provable_false)<br />              <span class="keyword">end</span><br /><br />              <span class="keyword">break</span> <span class="keyword">if</span> <span class="variable">@contradiction</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Return true if a statement is provable.</span><br />      <span class="comment"># Return false if its negation is provable.</span><br />      <span class="comment"># Return nil if it is undecidable.</span><br />      <span class="keyword">def</span> test(*args)<br />        x, y, type = get_stmt(*args)<br />        <span class="keyword">case</span> <span class="keyword">self</span>[x,y]<br />        <span class="keyword">when</span> <span class="keyword">nil</span><br />          <span class="keyword">return</span> <span class="keyword">nil</span><br />        <span class="keyword">when</span> type<br />          <span class="keyword">return</span> <span class="keyword">true</span><br />        <span class="keyword">else</span><br />          <span class="keyword">return</span> <span class="keyword">false</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="comment"># ...</span><br /><br /></div></div>
			<p>This class isn't as complicated as it appears, once you grasp the flow of how it's used.  When an assertion is made to the engine, it will first call test() to see if it already knows that information or if it contradicts any other information.</p>
			<p>Assuming the test passes, add_assertion() gets called.  That method starts by calling get_stmt() to turn its arguments into two properties and a type (:provable_true or :provable_false).  Note that the return sequence of get_stmt(), uses add_property() to ensure that the graph already contains basic relationships for that property (all dogs are dogs, for example).  These basic relationships are added using safe_add_edge(), which is really just a shell over add_edge() that filters out the symbols that are thrown by the latter.  Getting back to add_assertion(), we can see that it too uses add_edge(), but it returns the symbol thrown or its own :normal to indicate if we already knew about the assertion or if it contradicts what we did know.  I know that's a lot to take in, but if you just follow the chain of method calls it's pretty basic stuff.</p>
			<p>Finally, deduce() is called after an assertion has been added.  By walking the edges, deduce() will fill in any details the new assertion uncovers.  This is done by checking relationships between three independent complete sets of vertices, so relationships of the form one -&gt; two -&gt; three will be spotted.</p>
			<p>You can see that this class is always monitoring for a @contradiction in each of these methods.  However, I don't think this ever comes into play, since each assertion is tested before it's added.  (Correct me if I'm wrong Paulo!)</p>
			<p>On to the user interface:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="comment"># ...</span><br /><br />    [<span class="string">"Assertion"</span>, <span class="string">"Question"</span>].each <span class="keyword">do</span> |c|<br />      Struct.new(c, :x, :y, :type)<br />    <span class="keyword">end</span><br /><br />    <span class="keyword">class</span> UI<br /><br />      <span class="comment"># Parse input and return a statement</span><br />      <span class="keyword">def</span> get_statement(line)<br />        <span class="keyword">case</span> line<br />        <span class="comment"># assertions</span><br />        <span class="keyword">when</span> <span class="string">/^all (.*)s are (.*)s\.?$/</span><br />          <span class="keyword">return</span> Struct::Assertion.new( Property.create(<span class="global">$1</span>),<br />                                        Property.create(<span class="global">$2</span>),<br />                                        :provable_true )<br />        <span class="keyword">when</span> <span class="string">/^no (.*)s are (.*)s\.?$/</span><br />          <span class="keyword">return</span> Struct::Assertion.new( Property.create(<span class="global">$1</span>),<br />                                        Property.create(<span class="global">$2</span>).opposite,<br />                                        :provable_true )<br />        <span class="keyword">when</span> <span class="string">/^some (.*)s are not (.*)s\.?$/</span><br />          <span class="keyword">return</span> Struct::Assertion.new( Property.create(<span class="global">$1</span>),<br />                                        Property.create(<span class="global">$2</span>),<br />                                        :provable_false )<br />        <span class="keyword">when</span> <span class="string">/^some (.*)s are (.*)s\.?$/</span><br />          <span class="keyword">return</span> Struct::Assertion.new( Property.create(<span class="global">$1</span>),<br />                                        Property.create(<span class="global">$2</span>).opposite,<br />                                        :provable_false )<br />        <span class="comment"># questions</span><br />        <span class="keyword">when</span> <span class="string">/^are all (.*)s (.*)s\?$/</span><br />          <span class="keyword">return</span> Struct::Question.new( Property.create(<span class="global">$1</span>),<br />                                       Property.create(<span class="global">$2</span>),<br />                                       :provable_true )<br />        <span class="keyword">when</span> <span class="string">/^are no (.*)s (.*)s\?$/</span><br />          <span class="keyword">return</span> Struct::Question.new( Property.create(<span class="global">$1</span>),<br />                                       Property.create(<span class="global">$2</span>).opposite,<br />                                       :provable_true )<br />        <span class="keyword">when</span> <span class="string">/^are any (.*)s not (.*)s\?$/</span><br />          <span class="keyword">return</span> Struct::Question.new( Property.create(<span class="global">$1</span>),<br />                                       Property.create(<span class="global">$2</span>),<br />                                       :provable_false )<br />        <span class="keyword">when</span> <span class="string">/^are any (.*)s (.*)s\?$/</span><br />          <span class="keyword">return</span> Struct::Question.new( Property.create(<span class="global">$1</span>),<br />                                       Property.create(<span class="global">$2</span>).opposite,<br />                                       :provable_false )<br />        <span class="comment"># description</span><br />        <span class="keyword">when</span> <span class="string">/^describe (.*)s\.?$/</span><br />          <span class="keyword">return</span> Property.create(<span class="global">$1</span>)<br />        <span class="keyword">else</span><br />          <span class="keyword">return</span> <span class="keyword">nil</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Return a description of the relation</span><br />      <span class="comment"># between x and y. </span><br />      <span class="comment"># Assume that x is positive and that</span><br />      <span class="comment"># x -&gt; y is not undecidable.</span><br />      <span class="keyword">def</span> describe_edge(x, y, aff = <span class="keyword">true</span>)<br />        <span class="keyword">case</span> <span class="variable">@k</span>[x,y]<br />        <span class="keyword">when</span> :provable_true<br />          <span class="keyword">case</span> y.type<br />          <span class="keyword">when</span> :positive<br />            <span class="keyword">return</span> <span class="string">"All #{x.name}s are #{y.name}s"</span><br />          <span class="keyword">when</span> :negative<br />            <span class="keyword">return</span> <span class="string">"No #{x.name}s are #{y.name}s"</span><br />          <span class="keyword">end</span><br />        <span class="keyword">when</span> :provable_false<br />          <span class="keyword">case</span> y.type<br />          <span class="keyword">when</span> :positive<br />            <span class="keyword">if</span> aff<br />              <span class="keyword">return</span> <span class="string">"Some #{x.name}s are not #{y.name}s"</span><br />            <span class="keyword">else</span><br />              <span class="keyword">return</span> <span class="string">"Not all #{x.name}s are #{y.name}s"</span><br />            <span class="keyword">end</span><br />          <span class="keyword">when</span> :negative<br />            <span class="keyword">if</span> aff<br />              <span class="keyword">return</span> <span class="string">"Some #{x.name}s are #{y.name}s"</span><br />            <span class="keyword">else</span><br />              <span class="keyword">return</span> <span class="string">"Not all #{x.name}s are not #{y.name}s"</span><br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="comment"># Return a list of sentences which describe</span><br />      <span class="comment"># the relations between x and each other node.</span><br />      <span class="comment"># Assume that x is positive.</span><br />      <span class="keyword">def</span> describe_node(x)<br />        res = []<br />        <span class="variable">@k</span>.each_vertex <span class="keyword">do</span> |y|<br />          <span class="keyword">if</span> y.type == :positive <span class="keyword">and</span> <span class="keyword">not</span> x == y<br />            <span class="keyword">if</span> <span class="variable">@k</span>[x,y] == :provable_true<br />              res &lt;&lt; describe_edge(x,y)<br />            <span class="keyword">elsif</span> <span class="variable">@k</span>[x,y.opposite] == :provable_true<br />              res &lt;&lt; describe_edge(x,y.opposite)<br />            <span class="keyword">elsif</span> <span class="variable">@k</span>[x,y]<br />              res &lt;&lt; describe_edge(x,y)<br />            <span class="keyword">elsif</span> <span class="variable">@k</span>[x,y.opposite]<br />              res &lt;&lt; describe_edge(x,y.opposite)<br />            <span class="keyword">end</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br /><br />        res<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> say(value)<br />        <span class="keyword">case</span> value<br />        <span class="keyword">when</span> <span class="keyword">true</span><br />          <span class="string">"Yes"</span><br />        <span class="keyword">when</span> <span class="keyword">false</span><br />          <span class="string">"No"</span><br />        <span class="keyword">else</span><br />          <span class="string">"I don't know"</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> initialize<br />        <span class="variable">@k</span> = Knowledge.new<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> wait_for_input<br />        print <span class="string">'&gt; '</span><br />        gets<br />      <span class="keyword">end</span><br /><br />      <span class="keyword">def</span> run<br />        <span class="keyword">while</span> line = wait_for_input<br />          line.chomp!<br />          line.downcase!<br />          stmt = get_statement(line)<br />          <span class="keyword">if</span> stmt.<span class="keyword">class</span> == Struct::Assertion<br />            <span class="keyword">case</span> <span class="variable">@k</span>.test(stmt)<br />            <span class="keyword">when</span> <span class="keyword">true</span><br />              puts <span class="string">"I know"</span><br />            <span class="keyword">when</span> <span class="keyword">false</span><br />              puts <span class="string">"Sorry, that contradicts what I already know"</span><br />            <span class="keyword">else</span><br />              <span class="variable">@k</span>.add_assertion(stmt)<br />              <span class="variable">@k</span>.deduce<br />              puts <span class="string">"OK"</span><br />            <span class="keyword">end</span><br />          <span class="keyword">elsif</span> stmt.<span class="keyword">class</span> == Struct::Question<br />            value = <span class="variable">@k</span>.test(stmt)<br />            print say(value)<br />            <span class="keyword">if</span> value.nil?<br />              print <span class="string">"\n"</span><br />            <span class="keyword">else</span><br />              puts <span class="string">", #{describe_edge(stmt.x, stmt.y, value).downcase}"</span><br />            <span class="keyword">end</span><br />          <span class="keyword">elsif</span> stmt.<span class="keyword">class</span> == Property<br />            describe_node(stmt).each <span class="keyword">do</span> |sentence|<br />              puts sentence<br />            <span class="keyword">end</span><br />          <span class="keyword">else</span><br />            puts <span class="string">"I don't understand"</span><br />          <span class="keyword">end</span><br />        <span class="keyword">end</span><br />      <span class="keyword">end</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">def</span> debug_msg(msg)<br />      puts msg <span class="keyword">if</span> <span class="global">$debug</span><br />    <span class="keyword">end</span><br /><br />    <span class="keyword">if</span> <span class="global">$0</span> == <span class="keyword">__FILE__</span><br />      ui = UI.new<br />      ui.run<br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>Again, this looks like a lot of code, but it's not overly complicated, once you find the flow.  Look at the last few lines to get a hint about where to begin.  First, initialize() creates a Knowledge object to keep tract of our assertions and answer our questions.  From that point on, run() handles the interactive session.</p>
			<p>The first thing you need to know is that run() uses a couple of helper methods:  say() for output and wait_for_input() for input.  It also calls get_statement() to parse input.  The return from get statement is either a single Property (the "describe" command), a Struct::Assertion representing an assertion made, or a Struct::Question representing a question asked.  You can see those Structs defined just before the UI class starts.  They're just two properties and a type.</p>
			<p>The other thing to notice about get_statement() is that it does very basic Regexp based parsing.  It uses a super clever trick of spotting a trailing "s" to find the two groups in a line like, "Are all Ruby programmers happy programmers?"  Of course, this does not work across all legal inputs:</p>
			<p class="example">&gt; All oxen are mammals.<br />I don't understand<br />&gt; All James's pets are Dana's pets.<br />OK<br />&gt; Are all James's pets Dana's pets?<br />I don't know</p>
			<p>To see another approach, examine Pit Capitain's parsing, especially the IE.split() method.</p>
			<p>Getting back to run() in Paulo's UI class, you'll see that the rest of the method just handles the three different returns from get_statement().  Assertions are handled as I explained earlier.  Questions rely on describe_edge() for answers and the "describe" command triggers a call to describe_node().  That's the entire UI.</p>
			<p>I promise to end this long summary very soon now, but I wanted to mention just one more detail.  Paulo uses a helper method all through the code that's defined near the end.  Here's another look at it:</p>
			<div class="code"><span class="type">ruby</span><div class="body">    <span class="keyword">def</span> debug_msg(msg)<br />      puts msg <span class="keyword">if</span> <span class="global">$debug</span><br />    <span class="keyword">end</span><br /><br /></div></div>
			<p>The goal here is obvious, print a lot of extra information if I set this global variable to true.  This is a trick that we all use sometimes in testing.  I just wanted to suggest one minor change to enhance this trick:  Switch $debug to $DEBUG.  Then you can trigger the messages with a command-line switch like so:</p>
			<p class="example">$ ruby -e 'p $DEBUG'<br />false<br />$ ruby -d -e 'p $DEBUG'<br />true</p>
			<p>Slide that one into your bag of tricks, because it comes in handy.</p>
			<p>My thanks to all three submitters for some really great code to poke around in and play with.</p>
			<p>Tomorrow, we have a simple but handy hack to explore.  It's an easy quiz so I want to see all you beginners out there playing along!</p>
		</div>
		<div id="logo"><img src="/web/20120121210633im_/http://rubyquiz.com/images/ruby_quiz_logo.jpg" alt="" width="157" height="150" /></div>
		<div id="links">
			<span class="title">Quiz Solutions</span>
			<ol>
				<li><a href="/web/20120121210633/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147157">Paulo Capriotti</a></li>
				<li><a href="/web/20120121210633/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147189">Daniel Sheppard</a></li>
				<li><a href="/web/20120121210633/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147191">Daniel Sheppard (2)</a></li>
				<li><a href="/web/20120121210633/http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/147257">Pit Capitain</a></li>
			</ol>
			<p><a href="/web/20120121210633/http://rubyquiz.com/quiz37_sols.zip">Download Solutions</a></p>
			<p><a href="/web/20120121210633/http://rubyquiz.com/index.html">Back to Quiz Listing</a></p>
		</div>
		<div id="footer">&nbsp;</div>
	</div>
</body>
</html>





<!--
     FILE ARCHIVED ON 21:06:33 Jan 21, 2012 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 13:09:34 Jun 5, 2013.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
